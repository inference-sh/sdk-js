// Code generated by tygo. DO NOT EDIT.

//////////
// source: agent.go

/**
 * InternalToolsConfig controls which built-in tools are enabled for an agent
 */
export interface InternalToolsConfig {
  plan?: boolean; // Plan tools (Create, Update, Load) - default: true
  memory?: boolean; // Memory tools (Set, Get, GetAll) - default: true
  widget?: boolean; // Widget tools (UI, HTML) - default: true, top-level only
  finish?: boolean; // Finish tool - default: true (sub-agents only)
  skills?: boolean; // Skills tool (skill_get) - default: true when skills defined
  host_context?: boolean; // Host context tool (client-side, embed) - default: false
}
/**
 * ToolType represents the type of tool (used in both AgentTool definition and ToolInvocation)
 */
export type ToolType = string;
export const ToolTypeApp: ToolType = "app"; // App tools - creates a Task
export const ToolTypeAgent: ToolType = "agent"; // Sub-agent tools - creates a sub-Chat
export const ToolTypeHook: ToolType = "hook"; // Webhook tools - HTTP POST to external URL
export const ToolTypeClient: ToolType = "client"; // Client tools - executed by frontend
export const ToolTypeInternal: ToolType = "internal"; // Internal/built-in tools (plan, memory, widget, finish)
/**
 * AppToolConfig contains configuration for an app tool
 */
export interface AppToolConfig {
  /**
   * Ref is the human-readable reference: "namespace/name@shortVersionId"
   * This is what users specify in configs/SDKs
   */
  ref: string;
  /**
   * ID and VersionID are resolved full database UUIDs (populated at runtime)
   */
  id?: string;
  version_id?: string;
  /**
   * Resolved app object (populated at runtime)
   */
  app?: App;
  /**
   * Function to call on multi-function apps (empty = app's default function)
   */
  function?: string;
  /**
   * SessionEnabled allows the agent to control sessions for this tool
   * When true, agent can pass session parameter and sees session_id in output
   */
  session_enabled?: boolean;
  /**
   * Pre-configured values
   */
  setup?: any; // One-time setup values
  input?: any; // Default input values (merged with agent's call)
}
/**
 * AgentToolConfig contains configuration for a sub-agent tool
 */
export interface AgentToolConfig {
  /**
   * Ref is the human-readable reference: "namespace/name@shortVersionId"
   * This is what users specify in configs/SDKs
   */
  ref: string;
  /**
   * ID and VersionID are resolved full database UUIDs (populated at runtime)
   */
  id?: string;
  version_id?: string;
  /**
   * Resolved agent object (populated at runtime)
   */
  agent?: Agent;
}
/**
 * HookToolConfig contains configuration for a webhook tool
 */
export interface HookToolConfig {
  url: string;
  secret?: string;
  input_schema?: any;
  output_schema?: any;
}
/**
 * ClientToolConfig contains configuration for a frontend-executed tool
 */
export interface ClientToolConfig {
  input_schema?: any;
  output_schema?: any;
}
/**
 * AgentTool represents a unified tool that can be used by an agent
 */
export interface AgentTool {
  name: string;
  display_name?: string;
  description: string;
  type: ToolType;
  /**
   * Human-in-the-Loop: if true, tool execution requires user approval
   */
  require_approval?: boolean;
  /**
   * Type-specific config (exactly one should be set based on Type)
   */
  app?: AppToolConfig;
  agent?: AgentToolConfig;
  hook?: HookToolConfig;
  client?: ClientToolConfig;
  internal?: InternalToolConfig;
}
/**
 * InternalToolConfig contains configuration for internal/built-in tools
 */
export interface InternalToolConfig {
  category: string; // plan, memory, widget, finish
  operation: string; // create, update, load, set, get, ui, html, etc.
}
/**
 * AgentToolDTO for API responses
 */
export interface AgentToolDTO {
  name: string;
  display_name?: string;
  description: string;
  type: ToolType;
  /**
   * Human-in-the-Loop: if true, tool execution requires user approval
   */
  require_approval?: boolean;
  app?: AppToolConfigDTO;
  agent?: AgentToolConfigDTO;
  hook?: HookToolConfigDTO;
  client?: ClientToolConfigDTO;
}
export interface AppToolConfigDTO {
  ref: string;
  id?: string;
  version_id?: string;
  app?: AppDTO;
  /**
   * Function to call on multi-function apps
   */
  function?: string;
  /**
   * SessionEnabled allows the agent to control sessions for this tool
   */
  session_enabled?: boolean;
  /**
   * Pre-configured values
   */
  setup?: any;
  input?: any;
}
export interface AgentToolConfigDTO {
  ref: string;
  id?: string;
  version_id?: string;
  agent?: AgentDTO;
}
export interface HookToolConfigDTO {
  url: string;
  secret?: string;
  input_schema?: any;
  output_schema?: any;
}
export interface ClientToolConfigDTO {
  input_schema?: any;
  output_schema?: any;
}
/**
 * CoreAppConfig references an app used as the agent's core
 */
export interface CoreAppConfig {
  id?: string;
  version_id?: string;
  /**
   * CoreAppRef is the user-facing ref (namespace/name@shortid) - used in ad-hoc configs, resolved at creation
   */
  ref?: string;
  /**
   * Setup values for the core app (one-time configuration)
   */
  setup?: any;
  /**
   * Input default values for the core app
   */
  input?: any;
}
/**
 * AgentImages contains display images for an agent (like AppImages)
 */
export interface AgentImages {
  card: string;
  thumbnail: string;
  banner: string;
}
export interface Agent extends BaseModel, PermissionModel {
  ProjectModel: ProjectModel;
  /**
   * Basic info
   */
  namespace: string;
  name: string;
  /**
   * Display images (like App)
   */
  images: AgentImages;
  version_id: string;
  version?: AgentVersion;
}
/**
 * AgentDTO for API responses
 */
export interface AgentDTO extends BaseModel, PermissionModelDTO, ProjectModelDTO {
  namespace: string;
  name: string;
  /**
   * Display images (like AppDTO)
   */
  images: AgentImages;
  version_id: string;
  version?: AgentVersionDTO;
}
/**
 * SkillConfig defines a skill available to the agent.
 * Skills are loaded on-demand via the skill_get internal tool.
 */
export interface SkillConfig {
  name: string; // Unique identifier for the skill
  description: string; // Short description shown in tool listing
  url?: string; // URL to fetch skill content
  content?: string; // Inline skill content
}
/**
 * AgentConfig contains the shared configuration fields for agent execution.
 * This is embedded by both AgentVersion (DB model) and API request structs.
 * Using Go embedding flattens these fields in JSON serialization.
 */
export interface AgentConfig {
  /**
   * Optional name for the agent (used for adhoc agent deduplication — reuses existing agent by name).
   * Not persisted as a DB column; only used in API requests.
   */
  name?: string;
  description?: string;
  system_prompt?: string;
  example_prompts?: string[];
  /**
   * Core LLM configuration
   */
  core_app?: CoreAppConfig;
  /**
   * Tools (apps, agents, hooks, client tools)
   */
  tools?: (AgentTool | undefined)[];
  /**
   * Skills available to this agent (loaded on-demand via skill_get tool)
   */
  skills?: SkillConfig[];
  /**
   * Internal tools configuration (plan, memory, widget, finish, skills)
   */
  internal_tools?: InternalToolsConfig;
  /**
   * Output schema for custom finish tool (sub-agents only)
   */
  output_schema?: any;
}
export interface AgentVersion extends BaseModel, PermissionModel {
  agent_id: string;
  /**
   * ConfigHash for deduplication - SHA256 of config content
   */
  config_hash: string;
}
export interface CoreAppConfigDTO {
  id?: string;
  version_id?: string;
  ref?: string;
  app?: AppDTO;
  /**
   * Setup values for the core app (one-time configuration)
   */
  setup?: any;
  /**
   * Input default values for the core app
   */
  input?: any;
}
export interface AgentVersionDTO extends BaseModel, PermissionModelDTO {
  description: string;
  system_prompt: string;
  example_prompts: string[];
  core_app?: CoreAppConfigDTO;
  /**
   * Unified tools array (apps, agents, hooks, client)
   */
  tools: (AgentToolDTO | undefined)[];
  /**
   * Skills available to this agent (loaded on-demand via skill_get tool)
   */
  skills: SkillConfig[];
  /**
   * Internal tools configuration (plan, memory, widget, finish, skills)
   */
  internal_tools?: InternalToolsConfig;
  /**
   * Output schema for custom finish tool (sub-agents only)
   */
  output_schema?: any;
}

//////////
// source: api.go

export interface APIRequest<T extends any> {
  timestamp: string /* RFC3339 */;
  data: T;
}
export interface APIResponse<T extends any> {
  success: boolean;
  status: number /* int */;
  data?: T;
  error?: APIError;
}
/** Lightweight status-only response for polling transports */
export interface ResourceStatusDTO {
  id: string;
  status: any;
  updated_at: string;
}
export interface APIError {
  code: string;
  message: string;
}
/**
 * ApiAppRunRequest is the request body for /apps/run endpoint.
 * Supports two ways to specify the app:
 * 1. App ref (recommended): "namespace/name@shortid" in the App field
 * 2. Direct IDs: app_id + version_id fields (for internal platform use)
 */
export interface ApiAppRunRequest {
  /**
   * App reference in format: namespace/name@shortid (version required)
   * Example: "okaris/flux@abc1"
   * The short ID ensures your code always runs the same version.
   */
  app?: string;
  /**
   * Deprecated: use App ref instead. Direct ID bypasses ref routing.
   */
  app_id?: string;
  version_id?: string;
  infra?: Infra;
  workers?: string[];
  webhook?: string;
  setup?: any;
  input: any;
  /**
   * If true, returns SSE stream instead of JSON response
   */
  stream?: boolean;
  /**
   * Function to call on multi-function apps (defaults to "run" or app's default_function)
   */
  function?: string;
  /**
   * Session control: "new" to start a new session, "sess_xxx" to continue existing session
   * When using sessions, the worker is leased and state persists across calls
   */
  session?: string;
  /**
   * Session timeout in seconds (1-3600). Only valid when session="new"
   */
  session_timeout?: number /* int */;
}
/**
 * ApiAgentRunRequest is the request body for /agents/run endpoint.
 * Supports both template agents and ad-hoc agents.
 */
export interface ApiAgentRunRequest {
  /**
   * Existing chat ID to continue a conversation (optional)
   */
  chat_id?: string;
  /**
   * Template agent reference in format: namespace/name@shortid
   * Example: "my-org/assistant@abc123"
   * Use this OR AgentConfig, not both
   */
  agent?: string;
  /**
   * Ad-hoc agent configuration
   * For ad-hoc agents, set core_app.ref to the LLM app reference
   * Example: { "core_app": { "ref": "infsh/claude-sonnet-4@abc123" }, "system_prompt": "..." }
   */
  agent_config?: AgentConfig;
  /**
   * Optional name for the adhoc agent (used for deduplication and display)
   */
  agent_name?: string;
  /**
   * The message to send
   */
  input: ChatTaskInput;
  /**
   * If true, returns SSE stream instead of JSON response
   */
  stream?: boolean;
}
/**
 * EmbedAgentRunRequest is the embed variant of ApiAgentRunRequest.
 * Only template agents are supported (no ad-hoc configs).
 */
export interface EmbedAgentRunRequest {
  chat_id?: string;
  agent: string;
  input: ChatTaskInput;
  stream?: boolean;
}
export interface CreateAgentMessageRequest {
  chat_id?: string;
  agent_id?: string; // Deprecated: use Agent instead
  agent_version_id?: string; // Deprecated: use Agent instead
  agent?: string; // Template agent: namespace/name@shortid
  tool_call_id?: string;
  input: ChatTaskInput;
  integration_context?: IntegrationContext;
  /**
   * Ad-hoc agent config - use this instead of Agent for embedded configs
   * If provided, creates a chat with this config directly (no agent reference)
   */
  agent_config?: AgentConfig;
  /**
   * Optional name for the adhoc agent (used for deduplication and display)
   */
  agent_name?: string;
}
export interface CreateAgentMessageResponse {
  user_message?: ChatMessageDTO;
  assistant_message?: ChatMessageDTO;
}
/**
 * ToolResultRequest represents a tool result submission
 * For widget actions, clients should JSON-serialize { action, form_data } as the result string
 */
export interface ToolResultRequest {
  result: string;
}
/**
 * HookPayload represents the request body sent to a webhook when a hook tool is invoked
 */
export interface HookPayload {
  /**
   * Identification
   */
  tool_invocation_id: string;
  hook_name: string;
  /**
   * Callback - use this to submit the result back
   */
  callback_url: string;
  callback_method: string; // Always "POST"
  /**
   * Timestamp in RFC3339 format
   */
  timestamp: string;
  /**
   * The actual tool arguments from the LLM
   */
  arguments: { [key: string]: any};
}
/**
 * HookResponse represents the expected response from the hook URL
 * The hook should return 200 with success:true to acknowledge receipt
 * The actual result should be sent via the callback URL
 */
export interface HookResponse {
  success: boolean;
  message?: string;
}
export interface PartialFile {
  uri: string;
  path?: string;
  content_type?: string;
  size?: number /* int64 */;
  filename?: string;
}
export interface FileCreateRequest {
  /**
   * Category determines the storage path prefix: "uploads" (default), "inputs", "outputs", "repos"
   */
  category?: string;
  files: PartialFile[];
}
export interface CreateFlowRequest {
  name: string;
}
export interface CreateFlowRunRequest {
  flow: string;
  input: any;
}
/**
 * CreateAgentRequest is the request body for POST /agents
 * For new agents: omit ID, backend generates it
 * For new version of existing agent: include ID
 */
export interface CreateAgentRequest {
  /**
   * Existing agent ID (if updating/versioning)
   */
  id?: string;
  /**
   * Agent metadata
   */
  name: string;
  namespace?: string;
  images?: AgentImages;
  /**
   * Version config (embedded - backend generates version ID, timestamps, etc)
   */
  version?: AgentConfig;
}
/**
 * SDKTypes is a phantom struct that references types needed by the SDK.
 * This ensures the typegen traces these types without creating aliases.
 * Frontend uses generics like CursorListResponse<FlowDTO> directly.
 */
export interface SDKTypes {
}
export interface SkillPublishRequest {
  name: string;
  description: string;
  category: string;
  repo_url: string;
  license: string;
  allowed_tools: string;
  compatibility: string;
  instructions: string;
  files: SkillFile[];
  metadata?: { [key: string]: string};
  /**
   * Spec fields for roundtrip fidelity
   */
  disable_model_invocation: boolean;
  user_invocable?: boolean;
  context: string;
}
export interface CheckoutCreateRequest {
  amount: number /* int64 */;
  success_url: string;
  cancel_url: string;
}
export interface CheckoutCompleteRequest {
  session_id: string;
}
/**
 * Legacy aliases for backward compatibility
 */
export type StripeCheckoutCreateRequest = CheckoutCreateRequest;
export type StripeCheckoutCompleteRequest = CheckoutCompleteRequest;
/**
 * DeviceAuthResponse is returned when a device initiates auth
 */
export interface DeviceAuthResponse {
  user_code: string; // The code to show the user
  device_code: string; // The code for polling
  poll_url: string; // URL to poll for status
  approve_url: string; // URL for user to visit
  expires_in: number /* int */; // Seconds until expiration
  interval: number /* int */; // Recommended polling interval in seconds
}
/**
 * DeviceAuthPollResponse is returned when polling for auth status
 */
export interface DeviceAuthPollResponse {
  status: DeviceAuthStatus; // pending, approved, expired, denied
  api_key?: string; // Only set when status is approved
  team_id?: string; // Only set when status is approved
}
/**
 * DeviceAuthApproveRequest is sent when user approves the auth request
 */
export interface DeviceAuthApproveRequest {
  code: string; // The user_code
  team_id: string; // The team to associate the API key with
}
/**
 * DeviceAuthApproveResponse is returned after approval
 */
export interface DeviceAuthApproveResponse {
  success: boolean;
  message?: string;
}
/**
 * DeviceAuthCodeInfo contains info about a pending auth code (for display on approve page)
 */
export interface DeviceAuthCodeInfo {
  user_code: string;
  expires_at: string /* RFC3339 */;
  valid: boolean;
  status: DeviceAuthStatus; // pending, approved, expired
}
/**
 * MeResponse is returned from GET /me with user and current team info
 */
export interface MeResponse {
  user?: UserDTO;
  team?: TeamDTO;
}
export interface TeamCreateRequest {
  name: string;
  username: string;
  email: string;
}
/**
 * TeamSetupRequest is used for completing team setup (choosing username)
 * This marks the team as setup_completed=true after validation
 */
export interface TeamSetupRequest {
  username: string;
}
export interface TeamMemberAddRequest {
  email: string;
  role: TeamRole;
}
export interface TeamMemberUpdateRoleRequest {
  role: TeamRole;
}
/**
 * SecretCreateRequest for creating a new secret
 */
export interface SecretCreateRequest {
  key: string;
  value: string;
  description?: string;
}
/**
 * SecretUpdateRequest for updating a secret value
 */
export interface SecretUpdateRequest {
  value: string;
  description?: string; // Pointer to allow unsetting
}
/**
 * IntegrationConnectRequest for initiating an integration connection
 */
export interface IntegrationConnectRequest {
  provider: string;
  type: string;
  scopes?: string[];
  /**
   * For API Key type
   */
  api_key?: string;
  /**
   * For BYOK integrations (e.g., X.com) - contains user-provided credentials
   */
  metadata?: { [key: string]: any};
}
/**
 * IntegrationCompleteOAuthRequest for completing an OAuth flow
 */
export interface IntegrationCompleteOAuthRequest {
  provider: string;
  type: string;
  code: string;
  state: string;
  /**
   * For PKCE - code_verifier to complete the exchange (required by some providers like X/Twitter)
   */
  code_verifier?: string;
}
/**
 * IntegrationConnectResponse after connecting
 */
export interface IntegrationConnectResponse {
  integration?: IntegrationDTO;
  /**
   * For OAuth - redirect URL to start the flow
   */
  auth_url?: string;
  /**
   * For OAuth - state to be returned with the callback (frontend stores this)
   */
  state?: string;
  /**
   * For PKCE - code_verifier to be stored and sent back with CompleteOAuth (required by some providers like X/Twitter)
   */
  code_verifier?: string;
  /**
   * For service accounts - instructions
   */
  instructions?: string;
}
export interface ProjectCreateRequest {
  name: string;
  type: ProjectType;
}
export interface ProjectUpdateRequest {
  name: string;
}
export interface MoveAgentToProjectRequest {
  agent_id: string;
  project_id: string;
}

//////////
// source: api_internal.go

export interface WorkerGPUConfig {
  gpus: number /* int */[];
}
export interface WorkerCPUConfig {
  count: number /* int */;
}
export interface WorkerConfig {
  gpu: WorkerGPUConfig[];
  cpu: WorkerCPUConfig;
}
export interface EngineConfig {
  id: string;
  name: string;
  api_url: string;
  engine_port: string;
  workers: WorkerConfig;
  api_key: string;
  container_mode: boolean;
  network_name: string;
  cache_path: string;
  gpus: string[];
}

//////////
// source: app.go

export type AppCategory = string;
export const AppCategoryImage: AppCategory = "image";
export const AppCategoryVideo: AppCategory = "video";
export const AppCategoryAudio: AppCategory = "audio";
export const AppCategoryText: AppCategory = "text";
export const AppCategoryChat: AppCategory = "chat";
export const AppCategory3D: AppCategory = "3d";
export const AppCategoryOther: AppCategory = "other";
export const AppCategoryFlow: AppCategory = "flow";
export type GPUType = string;
export const GPUTypeAny: GPUType = "any";
export const GPUTypeNone: GPUType = "none";
export const GPUTypeIntel: GPUType = "intel";
export const GPUTypeNvidia: GPUType = "nvidia";
export const GPUTypeAMD: GPUType = "amd";
export const GPUTypeApple: GPUType = "apple";
export interface AppImages {
  card: string;
  thumbnail: string;
  banner: string;
}
export interface App extends BaseModel, PermissionModel {
  /**
   * Namespace is copied from team.username at creation time and is IMMUTABLE.
   * This ensures stable references like "namespace/name" even if team username changes.
   * Default empty string allows GORM migration to add column, then MigrateAppNamespaces populates it.
   */
  namespace: string;
  /**
   * Name is IMMUTABLE after creation. Combined with Namespace forms unique identifier.
   */
  name: string;
  description: string;
  agent_description: string;
  /**
   * Category is a fundamental classification of the app (image, video, audio, text, chat, 3d, other)
   */
  category: AppCategory;
  /**
   * Developer's images
   */
  images: AppImages;
  /**
   * Current version (developer's latest)
   */
  version_id: string;
  version?: AppVersion;
}
export interface AppGPUResource {
  count: number /* int */;
  vram: number /* int64 */;
  type: GPUType;
}
export interface AppResources {
  gpu: AppGPUResource;
  ram: number /* int */;
}
export interface AppVariant {
  name: string;
  order: number /* int */;
  resources: AppResources;
  env: { [key: string]: string};
  python: string;
}
/**
 * AppFunction represents a callable entry point within an app version.
 * Each function has its own input/output schema while sharing the app's setup.
 */
export interface AppFunction {
  name: string;
  description?: string;
  input_schema: any;
  output_schema: any;
}
export interface AppVersion extends BaseModel {
  app_id: string;
  metadata: { [key: string]: any};
  repository: string;
  flow_version_id?: string;
  flow_version?: FlowVersion;
  setup_schema: any;
  input_schema: any;
  output_schema: any;
  /**
   * Functions contains the callable entry points for this app version.
   * Each function has its own input/output schema. If nil/empty, the app uses legacy single-function mode
   * with InputSchema/OutputSchema at the version level.
   */
  functions?: { [key: string]: AppFunction};
  default_function?: string;
  variants: { [key: string]: AppVariant};
  env: { [key: string]: string};
  kernel: string;
  /**
   * App requirements - secrets and integrations needed to run this app
   */
  required_secrets?: SecretRequirement[];
  required_integrations?: IntegrationRequirement[];
  resources: AppResources;
  /**
   * Checksum is the SHA256 checksum of the uploaded zip file
   */
  checksum?: string;
}
export interface LicenseRecord extends BaseModel {
  user_id: string;
  app_id: string;
  license: string;
}
export interface AppDTO extends BaseModel, PermissionModelDTO {
  namespace: string;
  name: string;
  description: string;
  agent_description: string;
  category: AppCategory;
  images: AppImages;
  version_id: string;
  version?: AppVersionDTO;
}
export interface AppVersionDTO extends BaseModel {
  metadata: { [key: string]: any};
  repository: string;
  flow_version_id?: string;
  flow_version?: FlowVersionDTO;
  setup_schema: any;
  input_schema: any;
  output_schema: any;
  functions?: { [key: string]: AppFunction};
  default_function?: string;
  variants: { [key: string]: AppVariant};
  env: { [key: string]: string};
  kernel: string;
  /**
   * App requirements
   */
  required_secrets?: SecretRequirement[];
  required_integrations?: IntegrationRequirement[];
  resources: AppResources;
  /**
   * Checksum is the SHA256 checksum of the uploaded zip file
   */
  checksum?: string;
}

//////////
// source: app_session.go

export type AppSessionStatus = string;
export const AppSessionStatusActive: AppSessionStatus = "active";
export const AppSessionStatusEnded: AppSessionStatus = "ended";
export const AppSessionStatusExpired: AppSessionStatus = "expired";
export interface AppSession extends BaseModel, PermissionModel {
  /**
   * Affinity binding
   */
  worker_id: string;
  app_id: string;
  app_version_id: string;
  /**
   * Lifecycle
   */
  status: AppSessionStatus;
  expires_at: string /* RFC3339 */;
  ended_at?: string /* RFC3339 */;
  /**
   * Billing link
   */
  task_id?: string;
  /**
   * Stats
   */
  call_count: number /* int */;
  last_call_at?: string /* RFC3339 */;
  /**
   * Custom idle timeout in seconds (nil = use default)
   */
  idle_timeout?: number /* int */;
  /**
   * Relations
   */
  worker?: WorkerState;
  task?: Task;
}

//////////
// source: base.go

export interface BaseModel {
  id: string;
  short_id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  deleted_at?: string /* RFC3339 */;
}
/**
 * Visibility represents the visibility level of a resource
 */
export type Visibility = string;
export const VisibilityPrivate: Visibility = "private";
export const VisibilityPublic: Visibility = "public";
export const VisibilityUnlisted: Visibility = "unlisted";
export interface PermissionModel {
  user_id: string;
  user?: User;
  team_id: string;
  team?: Team;
  visibility: Visibility;
}
export interface PermissionModelDTO {
  user_id: string;
  user?: UserRelationDTO;
  team_id: string;
  team?: TeamRelationDTO;
  visibility: Visibility;
}

//////////
// source: chat.go

export type ChatStatus = string;
export const ChatStatusBusy: ChatStatus = "busy";
export const ChatStatusIdle: ChatStatus = "idle";
export const ChatStatusAwaitingInput: ChatStatus = "awaiting_input";
export const ChatStatusCompleted: ChatStatus = "completed";
export interface IntegrationContext {
  integration_type?: IntegrationType;
  integration_metadata?: any;
}
/**
 * ChatData contains agent-specific data for a chat session
 */
export interface ChatData {
  plan_steps: PlanStep[];
  memory: StringEncodedMap;
  always_allowed_tools: string[];
}
/**
 * PlanStep represents a step in an agent's execution plan
 */
export interface PlanStep {
  index: number /* int */;
  title: string;
  description: string;
  notes?: string;
  status: PlanStepStatus;
}
/**
 * PlanStepStatus represents the status of a plan step
 */
export type PlanStepStatus = string;
export const PlanStepStatusPending: PlanStepStatus = "pending";
export const PlanStepStatusInProgress: PlanStepStatus = "in_progress";
export const PlanStepStatusCompleted: PlanStepStatus = "completed";
export const PlanStepStatusCancelled: PlanStepStatus = "cancelled";
export type ChatMessageRole = string;
export const ChatMessageRoleSystem: ChatMessageRole = "system";
export const ChatMessageRoleUser: ChatMessageRole = "user";
export const ChatMessageRoleAssistant: ChatMessageRole = "assistant";
export const ChatMessageRoleTool: ChatMessageRole = "tool";
/**
 * ChatMessageStatus represents the lifecycle status of a chat message
 */
export type ChatMessageStatus = string;
export const ChatMessageStatusPending: ChatMessageStatus = "pending"; // Message is being generated
export const ChatMessageStatusReady: ChatMessageStatus = "ready"; // Message complete, tools ready for execution
export const ChatMessageStatusFailed: ChatMessageStatus = "failed"; // Message generation failed
export const ChatMessageStatusCancelled: ChatMessageStatus = "cancelled"; // Message was cancelled
export type ChatMessageContentType = string;
export const ChatMessageContentTypeText: ChatMessageContentType = "text";
export const ChatMessageContentTypeReasoning: ChatMessageContentType = "reasoning";
export const ChatMessageContentTypeImage: ChatMessageContentType = "image";
export const ChatMessageContentTypeFile: ChatMessageContentType = "file";
export const ChatMessageContentTypeTool: ChatMessageContentType = "tool";
export type IntegrationType = string;
export const IntegrationTypeSlack: IntegrationType = "slack";
export const IntegrationTypeDiscord: IntegrationType = "discord";
export const IntegrationTypeTeams: IntegrationType = "teams";
export const IntegrationTypeTelegram: IntegrationType = "telegram";
export interface ChatMessageContent {
  type: ChatMessageContentType;
  error?: string;
  text?: string;
  image?: string;
  file?: string;
  tool_calls?: ToolCall[];
}
/**
 * ToolCall represents a tool call from an LLM response (wire format)
 * This is a transport object for parsing LLM responses, not a database model
 */
export interface ToolCall {
  id: string;
  type: string; // "function"
  function: ToolCallFunction;
}
/**
 * ToolCallFunction contains the function name and arguments from an LLM tool call
 */
export interface ToolCallFunction {
  name: string;
  arguments: StringEncodedMap;
}
export interface ChatTaskInput {
  model?: string;
  context_size: number /* int */;
  temperature?: number /* float64 */;
  top_p?: number /* float64 */;
  reasoning_effort?: string;
  reasoning_max_tokens?: number /* int */;
  system_prompt: string;
  context: ChatTaskContextMessage[];
  role?: ChatMessageRole;
  text?: string;
  reasoning?: string;
  images?: string[];
  files?: string[];
  tools?: Tool[];
  tool_call_id?: string;
}
export interface ChatTaskContextMessage {
  role: ChatMessageRole;
  text?: string;
  reasoning?: string;
  images?: string[];
  files?: string[];
  tools?: Tool[];
  tool_calls?: ToolCall[];
  tool_call_id?: string;
}
export interface ChatDTO extends BaseModel, PermissionModelDTO {
  parent_id?: string;
  parent?: ChatDTO;
  children: (ChatDTO | undefined)[];
  status: ChatStatus;
  /**
   * Agent version reference
   */
  agent_id?: string;
  agent?: AgentDTO;
  agent_version_id?: string;
  agent_version?: AgentVersionDTO;
  name: string;
  description: string;
  chat_messages: ChatMessageDTO[];
  agent_data: ChatData;
}
export interface ChatMessageDTO extends BaseModel, PermissionModelDTO {
  chat_id: string;
  chat?: ChatDTO;
  order: number /* int */;
  status: ChatMessageStatus;
  task_id?: string;
  role: ChatMessageRole;
  content: ChatMessageContent[];
  tools?: Tool[];
  tool_call_id?: string;
  tool_invocations?: ToolInvocationDTO[];
}

//////////
// source: common.go

export type StringEncodedMap = { [key: string]: any};

//////////
// source: cursor.go

/**
 * SearchRequest represents a search request
 */
export interface SearchRequest {
  fields: string[];
  term: string;
  exact: boolean;
}
/**
 * Filter represents a single filter condition
 */
export interface Filter {
  field: string;
  operator: FilterOperator;
  value: any;
}
/**
 * FilterOperator represents the type of filter operation
 */
export type FilterOperator = string;
export const OpEqual: FilterOperator = "eq";
export const OpNotEqual: FilterOperator = "neq";
export const OpIn: FilterOperator = "in";
export const OpNotIn: FilterOperator = "not_in";
export const OpGreater: FilterOperator = "gt";
export const OpGreaterEqual: FilterOperator = "gte";
export const OpLess: FilterOperator = "lt";
export const OpLessEqual: FilterOperator = "lte";
export const OpLike: FilterOperator = "like";
export const OpILike: FilterOperator = "ilike";
export const OpContains: FilterOperator = "contains";
export const OpNotContains: FilterOperator = "not_contains";
/**
 * Null checks
 */
export const OpIsNull: FilterOperator = "is_null";
export const OpIsNotNull: FilterOperator = "is_not_null";
/**
 * Empty checks (for strings)
 */
export const OpIsEmpty: FilterOperator = "is_empty";
export const OpIsNotEmpty: FilterOperator = "is_not_empty";
/**
 * SortOrder represents sorting configuration
 */
export interface SortOrder {
  field: string;
  dir: string; // "asc" or "desc"
}
/**
 * CursorListRequest represents a cursor-based list request with all options
 */
export interface CursorListRequest {
  cursor: string;
  page?: number /* int */; // Page number for offset-based pagination (used when Cursor is empty)
  limit: number /* int */;
  direction: string;
  search?: SearchRequest;
  filters: Filter[];
  preloads: string[];
  sort: SortOrder[];
  fields: string[]; // Fields to select, empty means all fields
  permissions: string[]; // Permissions to filter by, empty means all permissions
  include_others: boolean; // Include other users' items in the response
}
/**
 * CursorListResponse represents a cursor-based paginated response
 */
export interface CursorListResponse<T extends any> {
  items: T[];
  next_cursor: string; // Base64 encoded timestamp
  prev_cursor: string; // Base64 encoded timestamp
  has_next: boolean;
  has_previous: boolean;
  items_per_page: number /* int */;
  total_items: number /* int */;
}

//////////
// source: deviceauth.go

export type DeviceAuthStatus = string;
export const DeviceAuthStatusPending: DeviceAuthStatus = "pending";
export const DeviceAuthStatusApproved: DeviceAuthStatus = "approved";
export const DeviceAuthStatusExpired: DeviceAuthStatus = "expired";
export const DeviceAuthStatusDenied: DeviceAuthStatus = "denied";
export const DeviceAuthStatusValid: DeviceAuthStatus = "valid";
export const DeviceAuthStatusInvalid: DeviceAuthStatus = "invalid";
export const DeviceAuthStatusLoading: DeviceAuthStatus = "loading";

//////////
// source: engine.go

/**
 * Engine-related types
 */
export type EngineStatus = string;
export const EngineStatusRunning: EngineStatus = "running";
export const EngineStatusPending: EngineStatus = "pending";
export const EngineStatusStopping: EngineStatus = "stopping";
export const EngineStatusStopped: EngineStatus = "stopped";
export interface EngineState extends BaseModel, PermissionModel {
  instance?: Instance;
  transaction_id: string;
  config: EngineConfig;
  public_key: string;
  name: string;
  api_url: string;
  status: EngineStatus;
  system_info?: SystemInfo;
  workers: (WorkerState | undefined)[];
}
export interface EngineStateDTO extends BaseModel, PermissionModelDTO {
  instance?: Instance;
  config: EngineConfig;
  name: string;
  api_url: string;
  status: EngineStatus;
  system_info?: SystemInfo;
  workers: (WorkerStateDTO | undefined)[];
}
export interface EngineStateSummary extends BaseModel, PermissionModelDTO {
  instance?: Instance;
  name: string;
  status: EngineStatus;
  workers: (WorkerStateSummary | undefined)[];
}
/**
 * Worker-related types
 */
export type WorkerStatus = string;
export interface WorkerState extends BaseModel, PermissionModel {
  index: number /* int */;
  status: WorkerStatus;
  status_updated_at?: string /* RFC3339 */;
  engine_id: string;
  engine?: EngineState;
  task_id?: string;
  app_id: string;
  app_version_id: string;
  /**
   * App session lease
   */
  active_session_id?: string;
  active_session?: AppSession;
  gpus: WorkerGPU[];
  cpus: WorkerCPU[];
  rams: WorkerRAM[];
  /**
   * WarmApps tracks app+version combos with warm containers for scheduling optimization.
   * Format: "appID:versionID@setupHash" - managed by Engine, synced via heartbeat.
   * Not persisted to DB - this is ephemeral runtime state.
   */
  warm_apps?: string[];
}
export interface WorkerGPU {
  id: string;
  worker_id: string;
  gpu_id: string;
  type: GPUType;
  name: string;
  vram: number /* int64 */;
}
export interface WorkerCPU {
  id: string;
  worker_id: string;
  name: string;
  vendor_id: string;
  family: string;
  model: string;
  cores: number /* int */;
  frequency: string;
}
export interface WorkerRAM {
  id: string;
  worker_id: string;
  total: number /* uint64 */;
}
export interface WorkerStateDTO extends BaseModel {
  user_id: string;
  team_id: string;
  index: number /* int */;
  status: WorkerStatus;
  engine_id: string;
  task_id?: string;
  app_id: string;
  app_version_id: string;
  active_session_id?: string;
  gpus: WorkerGPU[];
  cpus: WorkerCPU[];
  rams: WorkerRAM[];
  system_info: SystemInfo;
  warm_apps?: string[];
}
export interface WorkerStateSummary {
  id: string;
  user_id: string;
  index: number /* int */;
  status: WorkerStatus;
  engine_id: string;
  engine_name: string;
  task_id?: string;
  app_id: string;
  app_version_id: string;
  active_session_id?: string;
  gpus: WorkerGPU[];
  cpus: WorkerCPU[];
  rams: WorkerRAM[];
}

//////////
// source: file.go

/**
 * FileMetadata holds probed media metadata cached on File records.
 */
export interface FileMetadata {
  type?: string; // "image", "video", "audio"
  width?: number /* int */;
  height?: number /* int */;
  duration?: number /* float64 */; // seconds
  fps?: number /* float64 */;
  sample_rate?: number /* int */;
  channels?: number /* int */;
  codec?: string;
}
export interface File extends BaseModel, PermissionModel {
  path: string;
  remote_path: string;
  upload_url: string;
  uri: string;
  content_type: string;
  size: number /* int64 */;
  filename: string;
  rating: ContentRating;
  metadata?: FileMetadata;
}
export interface FileDTO extends BaseModel, PermissionModelDTO {
  path: string;
  remote_path: string;
  upload_url: string;
  uri: string;
  content_type: string;
  size: number /* int64 */;
  filename: string;
  rating: ContentRating;
  metadata?: FileMetadata;
}

//////////
// source: flow.go

export interface FlowVersion extends BaseModel {
  /**
   * Permission fields - nullable for migration from existing data
   * After migration these will be populated from parent Flow
   */
  user_id: string;
  user?: User;
  team_id: string;
  team?: Team;
  flow_id: string;
  /**
   * ConfigHash for deduplication - SHA256 of config content
   */
  config_hash: string;
  /**
   * Flow graph configuration
   */
  input_schema: any;
  input: FlowRunInputs;
  output_schema: any;
  output_mappings: OutputMappings;
  node_data: FlowNodeDataMap;
  nodes: FlowNode[];
  edges: FlowEdge[];
  viewport?: FlowViewport;
}
export interface FlowViewport {
  x: number /* float64 */;
  y: number /* float64 */;
  zoom: number /* float64 */;
}
export interface FlowNode {
  id: string;
  type: string;
  position: FlowNodePosition;
}
export interface FlowNodePosition {
  x: number /* float64 */;
  y: number /* float64 */;
}
export interface FlowNodeData {
  app?: AppDTO;
  app_id: string;
  app_version_id: string;
  function?: string; // Function to call on multi-function apps (defaults to version's default)
  infra: Infra;
  workers: string[];
  setup?: any;
  additional?: any;
  task?: TaskDTO;
  task_id?: string;
}
export type FlowNodeDataMap = { [key: string]: FlowNodeData};
export interface FlowEdge {
  id: string;
  type: string;
  source: string;
  target: string;
  source_handle?: string;
  target_handle?: string;
}
/**
 * OutputFieldMapping represents a mapping from a source node's field to an output field in the flow output schema.
 */
export interface OutputFieldMapping {
  sourceNodeId: string;
  sourceFieldPath: string;
  outputFieldName: string;
  type: string;
  schema: any;
}
/**
 * OutputMappings is a map of output field name to OutputFieldMapping.
 */
export type OutputMappings = { [key: string]: OutputFieldMapping};
export interface FlowDTO extends BaseModel, PermissionModelDTO {
  name: string;
  description: string;
  card_image: string;
  thumbnail: string;
  banner_image: string;
  /**
   * Version references
   */
  draft_version_id: string;
  draft_version?: FlowVersionDTO;
  published_version_id: string;
  published_version?: FlowVersionDTO;
  /**
   * Flattened draft version fields for backward compatibility
   * These come from the draft version (the editable one)
   */
  input_schema: any;
  input: FlowRunInputs;
  output_schema: any;
  output_mappings: OutputMappings;
  node_data: FlowNodeDataMap;
  nodes: FlowNode[];
  edges: FlowEdge[];
  viewport?: FlowViewport;
}
export interface FlowVersionDTO extends BaseModel {
  input_schema: any;
  input: FlowRunInputs;
  output_schema: any;
  output_mappings: OutputMappings;
  node_data: FlowNodeDataMap;
  nodes: FlowNode[];
  edges: FlowEdge[];
  viewport?: FlowViewport;
}
export interface NodeTaskDTO {
  task_id: string;
  task?: TaskDTO;
}
export type FlowRunStatus = number /* int */;
export const FlowRunStatusUnknown: FlowRunStatus = 0; // 0
export const FlowRunStatusPending: FlowRunStatus = 1; // 1
export const FlowRunStatusRunning: FlowRunStatus = 2; // 2
export const FlowRunStatusCompleted: FlowRunStatus = 3; // 3
export const FlowRunStatusFailed: FlowRunStatus = 4; // 4
export const FlowRunStatusCancelled: FlowRunStatus = 5; // 5
export interface FlowRunDTO extends BaseModel, PermissionModelDTO {
  flow_id: string;
  flow_version_id: string;
  flow_version?: FlowVersionDTO; // Snapshot at run time
  task_id?: string;
  status: FlowRunStatus;
  error?: string;
  flow_run_started?: string /* RFC3339 */;
  flow_run_finished?: string /* RFC3339 */;
  flow_run_cancelled?: string /* RFC3339 */;
  input: FlowRunInputs;
  fail_on_error: boolean;
  output: any;
  node_tasks: { [key: string]: NodeTaskDTO | undefined};
}
/**
 * Connection represents a connection between nodes in a flow
 */
export interface FlowNodeConnection {
  nodeId: string;
  key: string;
  type: string;
  previousValue: any;
}
export type FlowRunInputs = { [key: string]: { [key: string]: FlowRunInput}};
export interface FlowRunInput {
  Connection?: FlowNodeConnection;
  Value: any;
}

//////////
// source: graph.go

export type GraphNodeType = string;
export const GraphNodeTypeUnknown: GraphNodeType = "unknown";
export const GraphNodeTypeJoin: GraphNodeType = "join";
export const GraphNodeTypeSplit: GraphNodeType = "split";
export const GraphNodeTypeExecution: GraphNodeType = "execution";
export const GraphNodeTypeResource: GraphNodeType = "resource";
export const GraphNodeTypeApproval: GraphNodeType = "approval";
export const GraphNodeTypeConditional: GraphNodeType = "conditional";
export const GraphNodeTypeFlowNode: GraphNodeType = "flow_node"; // Flow execution node
/**
 * GraphNodeStatus represents the status of a node
 */
export type GraphNodeStatus = string;
export const GraphNodeStatusPending: GraphNodeStatus = "pending";
export const GraphNodeStatusReady: GraphNodeStatus = "ready"; // Dependencies satisfied
export const GraphNodeStatusRunning: GraphNodeStatus = "running";
export const GraphNodeStatusCompleted: GraphNodeStatus = "completed";
export const GraphNodeStatusFailed: GraphNodeStatus = "failed";
export const GraphNodeStatusCancelled: GraphNodeStatus = "cancelled";
export const GraphNodeStatusSkipped: GraphNodeStatus = "skipped"; // Conditional branch not taken
export const GraphNodeStatusBlocked: GraphNodeStatus = "blocked"; // Dependency failed
/**
 * GraphEdgeType defines the type of edge relationship
 */
export type GraphEdgeType = string;
export const GraphEdgeTypeDependency: GraphEdgeType = "dependency"; // Blocking dependency
export const GraphEdgeTypeFlow: GraphEdgeType = "flow"; // Non-blocking flow
export const GraphEdgeTypeConditional: GraphEdgeType = "conditional"; // Conditional flow
export const GraphEdgeTypeExecution: GraphEdgeType = "execution"; // Node → Resource execution link
/**
 * GraphNodeDTO is the API representation of a graph node
 */
export interface GraphNodeDTO extends BaseModel {
  graph_id: string;
  type: GraphNodeType;
  label: string;
  resource_id: string;
  resource_type: string;
  status: GraphNodeStatus;
  metadata?: StringEncodedMap;
  ready_at?: string /* RFC3339 */;
  started_at?: string /* RFC3339 */;
  completed_at?: string /* RFC3339 */;
  duration_ms?: number /* int64 */;
}
/**
 * GraphEdgeDTO is the API representation of a graph edge
 */
export interface GraphEdgeDTO extends BaseModel {
  type: GraphEdgeType;
  from_node: string;
  to_node: string;
}
/**
 * ChatTraceDTO is the trace response for chat observability
 */
export interface ChatTraceDTO {
  graph_id: string;
  nodes: (GraphNodeDTO | undefined)[];
  edges: (GraphEdgeDTO | undefined)[];
  /**
   * Summary stats
   */
  total_steps: number /* int */;
  completed_steps: number /* int */;
  running_steps: number /* int */;
  failed_steps: number /* int */;
}

//////////
// source: integration.go

/**
 * StringSlice is a custom type for storing string slices in the database
 */
export type StringSlice = string[];
/**
 * IntegrationDTO for API responses (never exposes tokens)
 */
export interface IntegrationDTO extends BaseModel, PermissionModelDTO {
  provider: string;
  type: string;
  status: string;
  display_name: string;
  scopes: StringSlice;
  expires_at?: string /* RFC3339 */;
  service_account_email?: string;
  metadata?: { [key: string]: any};
  account_identifier?: string; // e.g., email for Google, @username for X
  account_name?: string; // Display name of connected account
  is_primary: boolean; // Default account for this provider:type (for future multi-account support)
  error_message?: string;
}

//////////
// source: project.go

/**
 * ProjectType represents different types of projects
 */
export type ProjectType = string;
export const ProjectTypeAgent: ProjectType = "agent";
export const ProjectTypeApp: ProjectType = "app";
export const ProjectTypeFlow: ProjectType = "flow";
export const ProjectTypeOther: ProjectType = "other";
/**
 * ProjectModel provides optional project association for models
 */
export interface ProjectModel {
  project_id?: string;
  project?: Project;
}
export interface ProjectModelDTO {
  project_id?: string;
  project?: ProjectDTO;
}
/**
 * Project represents a container for organizing related resources
 */
export interface Project extends BaseModel, PermissionModel {
  name: string;
  description: string;
  type: ProjectType;
  color?: string;
  icon?: string;
  /**
   * For future: nested folders/projects
   */
  parent_id?: string;
  parent?: Project;
  children: (Project | undefined)[];
}
/**
 * ProjectDTO for API responses
 */
export interface ProjectDTO extends BaseModel, PermissionModelDTO {
  name: string;
  description: string;
  type: ProjectType;
  color?: string;
  icon?: string;
  parent_id?: string;
  parent?: ProjectDTO;
  children: (ProjectDTO | undefined)[];
}

//////////
// source: rating.go

export type ContentRating = string;
export const ContentSafe: ContentRating = "safe";
/**
 * sexual content
 */
export const ContentSexualSuggestive: ContentRating = "sexual_suggestive";
export const ContentSexualExplicit: ContentRating = "sexual_explicit";
/**
 * violence
 */
export const ContentViolenceNonGraphic: ContentRating = "violence_non_graphic";
export const ContentViolenceGraphic: ContentRating = "violence_graphic";
/**
 * gore
 */
export const ContentGore: ContentRating = "gore";
/**
 * other regulated content
 */
export const ContentDrugs: ContentRating = "drugs";
export const ContentSelfHarm: ContentRating = "self_harm";
export const ContentUnrated: ContentRating = "unrated";

//////////
// source: requirements.go

/**
 * SecretRequirement defines a secret that an app requires to run
 */
export interface SecretRequirement {
  key: string;
  description?: string;
  optional?: boolean;
}
/**
 * IntegrationRequirement defines an integration capability that an app requires
 */
export interface IntegrationRequirement {
  key: string; // e.g., "google.sheets", "google.sa"
  description?: string;
  optional?: boolean;
}
/**
 * RequirementError represents a single missing requirement with actionable info
 */
export interface RequirementError {
  type: string; // "secret" | "integration" | "scope"
  key: string; // The requirement key that's missing
  message: string; // Human-readable error message
  action?: SetupAction;
}
/**
 * SetupAction provides actionable info for resolving a missing requirement
 */
export interface SetupAction {
  type: string; // "add_secret" | "connect" | "add_scopes"
  provider?: string; // For integration actions
  scopes?: string[]; // Scopes to request
}

//////////
// source: secrets.go

/**
 * SecretRef tracks which Secret record provided a value for a task (for billing)
 */
export interface SecretRef {
  key: string;
  id: string;
  team_id: string;
}

//////////
// source: shadeform.go

export type InstanceCloudProvider = string;
export const CloudAWS: InstanceCloudProvider = "aws";
export const CloudAzure: InstanceCloudProvider = "azure";
export const CloudLambdaLabs: InstanceCloudProvider = "lambdalabs";
export const CloudTensorDock: InstanceCloudProvider = "tensordock";
export const CloudRunPod: InstanceCloudProvider = "runpod";
export const CloudLatitude: InstanceCloudProvider = "latitude";
export const CloudJarvisLabs: InstanceCloudProvider = "jarvislabs";
export const CloudOblivus: InstanceCloudProvider = "oblivus";
export const CloudPaperspace: InstanceCloudProvider = "paperspace";
export const CloudDatacrunch: InstanceCloudProvider = "datacrunch";
export const CloudMassedCompute: InstanceCloudProvider = "massedcompute";
export const CloudVultr: InstanceCloudProvider = "vultr";
export const CloudShade: InstanceCloudProvider = "shade";
export type InstanceStatus = string;
export const InstanceStatusPending: InstanceStatus = "pending";
export const InstanceStatusActive: InstanceStatus = "active";
export const InstanceStatusDeleted: InstanceStatus = "deleted";
export interface Instance extends BaseModel, PermissionModel {
  cloud: InstanceCloudProvider;
  name: string;
  region: string;
  shade_cloud: boolean;
  shade_instance_type: string;
  cloud_instance_type: string;
  cloud_assigned_id: string;
  os?: string;
  ssh_key_id?: string;
  ssh_user: string;
  ssh_port: number /* int */;
  ip: string;
  status: InstanceStatus;
  cost_estimate: string;
  hourly_price: number /* int */; // in cents
  template_id?: string;
  volume_ids?: string[];
  tags?: string[];
  configuration?: InstanceConfiguration;
  launch_configuration?: InstanceLaunchConfiguration;
  auto_delete?: InstanceThresholdConfig;
  alert?: InstanceThresholdConfig;
  volume_mount?: InstanceVolumeMountConfig;
  envs?: InstanceEnvVar[];
}
export interface InstanceConfiguration {
  gpu_type: string;
  interconnect: string;
  memory_in_gb: number /* int */;
  num_gpus: number /* int */;
  os: string;
  storage_in_gb: number /* int */;
  vcpus: number /* int */;
  vram_per_gpu_in_gb: number /* int */;
}
export interface InstanceLaunchConfiguration {
  type: string;
  docker_configuration?: InstanceDockerConfig;
  script_configuration?: InstanceScriptConfig;
}
export interface InstanceDockerConfig {
  image: string;
  args?: string;
  shared_memory_in_gb?: number /* int */;
  envs?: InstanceEnvVar[];
  port_mappings?: InstancePortMapping[];
  volume_mounts?: InstanceVolumeMount[];
}
export interface InstanceScriptConfig {
  base64_script: string;
}
export interface InstancePortMapping {
  host_port: number /* int */;
  container_port: number /* int */;
}
export interface InstanceVolumeMount {
  host_path: string;
  container_path: string;
}
export interface InstanceThresholdConfig {
  date_threshold?: string;
  spend_threshold?: string;
}
export interface InstanceVolumeMountConfig {
  auto: boolean;
}
export interface InstanceEnvVar {
  name: string;
  value: string;
}

//////////
// source: skill.go

/**
 * SkillFile represents a file in the skill directory (stored as JSONB in skill_versions)
 */
export interface SkillFile {
  path: string; // "SKILL.md", "references/foo.md", "scripts/bar.py"
  uri?: string; // public CDN URL from file service
  size: number /* int64 */; // bytes
  hash: string; // SHA256 of individual file
  content?: string; // input only — backend uploads to R2, then clears
}

//////////
// source: system_info.go

/**
 * Hardware/System related types
 */
export interface SystemInfo {
  hostname: string;
  engine_version: string;
  ipv4: string;
  ipv6: string;
  mac_address: string;
  os: string;
  docker: Docker;
  wsl2: WSL2;
  cpus: CPU[];
  ram: RAM;
  volumes: Volume[];
  hf_cache: HFCacheInfo;
  gpus: GPU[];
}
export interface TelemetrySystemInfo {
  cpus: CPU[];
  ram: RAM;
  gpus: GPU[];
  volumes: Volume[];
}
export interface Docker {
  binary_path: string;
  installed: boolean;
  socket_path: string;
  socket_available: boolean;
  running: boolean;
  version: string;
}
export interface WSL2 {
  installed: boolean;
  enabled: boolean;
  version: string;
}
export interface CPU {
  name: string;
  vendor_id: string;
  family: string;
  model: string;
  cores: number /* int */;
  frequency: string;
  usage: number /* float64 */;
  normalized_usage: number /* float64 */;
}
export interface Volume {
  name: string;
  size: number /* uint64 */;
  used: number /* uint64 */;
  free: number /* uint64 */;
  usage: number /* float64 */;
}
export interface RAM {
  total: number /* uint64 */;
  available: number /* uint64 */;
  used: number /* uint64 */;
  free: number /* uint64 */;
  usage: number /* float64 */;
  total_physical: number /* uint64 */;
  total_usable: number /* uint64 */;
  bootloader_usage: number /* uint64 */;
  swap_total: number /* uint64 */;
  swap_used: number /* uint64 */;
  swap_free: number /* uint64 */;
  swap_usage: number /* float64 */;
}
export interface GPU {
  id: string;
  name: string;
  index: number /* int */;
  cuda_version: string;
  driver_version: string;
  memory_used: number /* uint64 */;
  memory_total: number /* uint64 */;
  temperature: number /* uint32 */;
}
/**
 * CachedRevisionInfo represents information about a cached revision
 */
export interface CachedRevisionInfo {
  commit_hash: string;
  snapshot_path: string;
  last_modified: string /* RFC3339 */;
  size_on_disk: number /* int64 */;
  size_on_disk_str: string;
  nb_files: number /* int */;
  refs: string[];
}
/**
 * CachedRepoInfo represents information about a cached repository
 */
export interface CachedRepoInfo {
  repo_id: string;
  repo_type: string;
  repo_path: string;
  last_accessed: string /* RFC3339 */;
  last_modified: string /* RFC3339 */;
  size_on_disk: number /* int64 */;
  size_on_disk_str: string;
  nb_files: number /* int */;
  refs: string[];
  Revisions: CachedRevisionInfo[];
}
/**
 * HFCacheInfo represents information about the Huggingface cache
 */
export interface HFCacheInfo {
  cache_dir: string;
  repos: CachedRepoInfo[];
  size_on_disk: number /* int64 */;
  warnings: string[];
}

//////////
// source: task.go

/**
 * TaskStatus represents the state of a task in its lifecycle.
 * DESIGN NOTES:
 * - Stored as int in DB for compact storage and efficient equality checks.
 * - The int values are ordered to allow SQL range queries (status < ?) for performance.
 * - IMPORTANT: If you add new statuses in the MIDDLE of the sequence, you must:
 *  1. Write a migration to shift existing values
 *  2. Update SDKs and frontends
 *     - ALTERNATIVE: Add new statuses at the END to avoid migrations, but then you
 *     cannot use range comparisons (< >) and must use explicit checks (IN, NOT IN).
 *     - Kubernetes/Temporal use strings and explicit checks for maximum flexibility.
 *     Consider switching to strings if range comparisons become a maintenance burden.
 */
export type TaskStatus = number /* int */;
export const TaskStatusUnknown: TaskStatus = 0; // 0
export const TaskStatusReceived: TaskStatus = 1; // 1
export const TaskStatusQueued: TaskStatus = 2; // 2
export const TaskStatusScheduled: TaskStatus = 3; // 3
export const TaskStatusPreparing: TaskStatus = 4; // 4
export const TaskStatusServing: TaskStatus = 5; // 5
export const TaskStatusSettingUp: TaskStatus = 6; // 6
export const TaskStatusRunning: TaskStatus = 7; // 7
export const TaskStatusCancelling: TaskStatus = 8; // 8 - Graceful cancellation in progress
export const TaskStatusUploading: TaskStatus = 9; // 9
export const TaskStatusCompleted: TaskStatus = 10; // 10
export const TaskStatusFailed: TaskStatus = 11; // 11
export const TaskStatusCancelled: TaskStatus = 12; // 12
export type Infra = string;
export const InfraPrivate: Infra = "private";
export const InfraCloud: Infra = "cloud";
export const InfraPrivateFirst: Infra = "private_first";
export interface Task extends BaseModel, PermissionModel {
  is_featured: boolean;
  status: TaskStatus;
  /**
   * Foreign keys
   */
  app_id: string;
  app?: App;
  version_id: string;
  app_version?: AppVersion;
  /**
   * Deprecated: Will be removed in favor of Setup
   */
  variant: string;
  /**
   * Function is the specific function to call on multi-function apps.
   * DEPRECATED: Standardizing on explicit function name.
   * Defaults to "run" for legacy tasks (backfilled via migration).
   */
  function: string;
  infra: Infra;
  workers: string[];
  engine_id?: string;
  engine?: EngineState;
  worker_id?: string;
  worker?: WorkerState;
  /**
   * Belongs to:
   */
  flow_run_id?: string;
  chat_id?: string;
  /**
   * Owns: (Can be replaced with graph execution edge/node)
   */
  sub_flow_run_id?: string;
  webhook?: string;
  setup?: any;
  input: any;
  output: any;
  error: string;
  rating: ContentRating;
  /**
   * Relationships
   */
  events: TaskEvent[];
  logs: TaskLog[];
  telemetry: TimescaleTask[];
  usage_events: (UsageEvent | undefined)[];
  transaction_id?: string;
  transaction?: Transaction;
  /**
   * Secret refs for billing (tracks ownership to determine partner fee)
   */
  secrets?: SecretRef[];
  /**
   * App session reference (for session calls)
   * Special value "new" means scheduler should create session when dispatching.
   */
  session_id?: string;
  session?: AppSession;
  /**
   * Session timeout in seconds (only used when session="new")
   */
  session_timeout?: number /* int */;
}
export interface TaskEvent {
  id: string;
  created_at: string /* RFC3339 */;
  event_time: string /* RFC3339 */;
  task_id: string;
  status: TaskStatus;
}
export type TaskLogType = number /* int */;
export const TaskLogTypeBuild: TaskLogType = 0; // 0
export const TaskLogTypeRun: TaskLogType = 1;
export const TaskLogTypeServe: TaskLogType = 2;
export const TaskLogTypeSetup: TaskLogType = 3;
export const TaskLogTypeTask: TaskLogType = 4;
export interface TaskLog {
  id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  task_id: string;
  log_type: TaskLogType;
  content: string;
}
export interface TaskDTO extends BaseModel, PermissionModelDTO {
  graph_id?: string;
  user_public_key: string;
  engine_public_key: string;
  is_featured: boolean;
  status: TaskStatus;
  app_id: string;
  app?: AppDTO;
  app_version_id: string;
  app_version?: AppVersionDTO;
  app_variant: string;
  function: string; // Function called on multi-function apps
  infra: Infra;
  workers: string[];
  flow_run_id?: string;
  chat_id?: string;
  sub_flow_run_id?: string;
  agent_id?: string;
  agent_version_id?: string;
  agent?: AgentDTO;
  engine_id?: string;
  engine?: EngineStateSummary;
  worker_id?: string;
  worker?: WorkerStateSummary;
  webhook?: string;
  setup?: any;
  input: any;
  output: any;
  error: string;
  rating: ContentRating;
  events: TaskEvent[];
  logs: TaskLog[];
  telemetry: TimescaleTask[];
  usage_events: (UsageEvent | undefined)[];
  transaction_id?: string;
  transaction?: Transaction;
  session_id?: string;
  session_timeout?: number /* int */;
}
export interface TimescaleTask {
  id: string;
  timestamp: string /* RFC3339 */;
  task_id?: string;
  task_seq: number /* int */;
  app_id: string;
  app_version_id: string;
  engine_id: string;
  engine_resources: TelemetrySystemInfo;
  worker_id: string;
  system_info: TelemetrySystemInfo;
}

//////////
// source: team.go

export type TeamType = string;
export const TeamTypePersonal: TeamType = "personal";
export const TeamTypeTeam: TeamType = "team";
export const TeamTypeSystem: TeamType = "system";
export interface Team extends BaseModel {
  type: TeamType;
  username: string;
  email: string;
  name: string;
  avatar_url: string;
  /**
   * SetupCompleted indicates whether the team has completed initial setup (chosen a username)
   * Personal teams start with SetupCompleted=false and a generated temporary username
   */
  setup_completed: boolean;
}
export interface TeamDTO extends BaseModel {
  type: TeamType;
  name: string;
  username: string;
  avatar_url: string;
  email: string;
  setup_completed: boolean;
}
export type TeamRole = string;
export const TeamRoleOwner: TeamRole = "owner";
export const TeamRoleAdmin: TeamRole = "admin";
export const TeamRoleMember: TeamRole = "member";
/**
 * Team-related types
 */
export interface TeamRelationDTO {
  id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  type: TeamType;
  username: string;
  avatar_url: string;
  setup_completed: boolean;
}

//////////
// source: tools.go

/**
 * ToolInvocationFunction contains the function details for a tool invocation
 */
export interface ToolInvocationFunction {
  name: string;
  arguments: StringEncodedMap;
}
/**
 * ToolInvocationStatus represents the execution status of a tool invocation
 */
export type ToolInvocationStatus = string;
export const ToolInvocationStatusPending: ToolInvocationStatus = "pending";
export const ToolInvocationStatusInProgress: ToolInvocationStatus = "in_progress";
export const ToolInvocationStatusAwaitingInput: ToolInvocationStatus = "awaiting_input"; // Waiting for user input (widgets)
export const ToolInvocationStatusAwaitingApproval: ToolInvocationStatus = "awaiting_approval"; // Waiting for HIL approval
export const ToolInvocationStatusCompleted: ToolInvocationStatus = "completed";
export const ToolInvocationStatusFailed: ToolInvocationStatus = "failed";
export const ToolInvocationStatusCancelled: ToolInvocationStatus = "cancelled";
/**
 * ToolInvocationDTO for API responses
 */
export interface ToolInvocationDTO extends BaseModel, PermissionModelDTO {
  chat_message_id: string;
  tool_invocation_id: string;
  type: ToolType;
  display_name?: string;
  execution_id?: string;
  function: ToolInvocationFunction;
  status: ToolInvocationStatus;
  result?: string;
  /**
   * Unified fields
   */
  data?: any;
  widget?: Widget;
}
export interface Tool {
  type: string;
  function: ToolFunction;
}
export interface ToolFunction {
  name: string;
  description: string;
  parameters?: ToolParameters;
  required?: string[];
}
export interface ToolParameters {
  type: string;
  title: string;
  properties?: ToolParameterProperties;
  required?: string[];
}
export type ToolParameterProperties = { [key: string]: ToolParameterProperty};
export interface ToolParameterProperty {
  type: string;
  title: string;
  description: string;
  properties?: ToolParameterProperties;
  items?: ToolParameterProperty;
  required?: string[];
}

//////////
// source: tx.go

/**
 * TransactionType represents the type of credit transaction
 */
export type TransactionType = string;
export const TransactionTypeCredit: TransactionType = "credit"; // Adding credits
export const TransactionTypeDebit: TransactionType = "debit"; // Removing credits
/**
 * Transaction represents a single credit transaction
 */
export interface Transaction extends BaseModel {
  PermissionModel: PermissionModel; // Includes UserID
  type: TransactionType;
  amount: number /* int64 */; // Can be negative for debits
  reference: string; // External reference (e.g., payment ID)
  notes: string;
  /**
   * Metadata for the transaction
   */
  metadata: { [key: string]: any};
  /**
   * SideEffectsProcessed tracks whether side effects (notifications, auto-recharge,
   * billing status changes) have been processed for this transaction.
   * Set to true via WithSkipTxSideEffects context to skip side effects (e.g. migrations).
   */
  side_effects_processed: boolean;
}
/**
 * PaymentRecordStatus represents the status of a payment
 */
export type PaymentRecordStatus = number /* int */;
export const PaymentRecordStatusPending: PaymentRecordStatus = 0;
export const PaymentRecordStatusComplete: PaymentRecordStatus = 1;
export const PaymentRecordStatusFailed: PaymentRecordStatus = 2;
export const PaymentRecordStatusExpired: PaymentRecordStatus = 3;
/**
 * PaymentRecordType represents the type of payment
 */
export type PaymentRecordType = string;
export const PaymentRecordTypeCheckout: PaymentRecordType = "checkout"; // Stripe Checkout session (manual top-up)
export const PaymentRecordTypeAutoRecharge: PaymentRecordType = "auto_recharge"; // Direct charge (auto-recharge)
/**
 * PaymentRecord stores Stripe payment details for both checkout sessions and direct charges
 */
export interface PaymentRecord extends BaseModel, PermissionModel {
  type: PaymentRecordType;
  status: PaymentRecordStatus;
  amount: number /* int64 */; // Amount in cents (credit amount — what user gets)
  service_fee: number /* int64 */; // Service fee in cents (charged on top of Amount)
  stripe_customer_id: string; // Stripe customer ID
  payment_intent_id: string; // Stripe PaymentIntent ID
  receipt_url: string; // Receipt URL
  /**
   * Checkout-specific fields (only set for checkout type)
   */
  session_id: string; // Stripe Checkout Session ID
  session_url: string; // Checkout URL
}

//////////
// source: usage.go

export type UsageEventResourceTier = string;
export const UsageEventResourceTierPrivate: UsageEventResourceTier = "private";
export const UsageEventResourceTierCloud: UsageEventResourceTier = "cloud";
/**
 * MetaItemType is the type discriminator for MetaItem
 */
export type MetaItemType = string;
export const MetaItemTypeText: MetaItemType = "text";
export const MetaItemTypeImage: MetaItemType = "image";
export const MetaItemTypeVideo: MetaItemType = "video";
export const MetaItemTypeAudio: MetaItemType = "audio";
export const MetaItemTypeRaw: MetaItemType = "raw";
/**
 * VideoResolution represents standard video resolution presets
 */
export type VideoResolution = string;
export const VideoRes480P: VideoResolution = "480p";
export const VideoRes720P: VideoResolution = "720p";
export const VideoRes1080P: VideoResolution = "1080p";
export const VideoRes1440P: VideoResolution = "1440p";
export const VideoRes4K: VideoResolution = "4k";
/**
 * MetaItem represents metadata about an input or output item
 */
export interface MetaItem {
  type: MetaItemType;
  /**
   * Text fields
   */
  tokens?: number /* int */;
  /**
   * Image/Video shared fields
   */
  width?: number /* int */;
  height?: number /* int */;
  resolution_mp?: number /* float64 */;
  /**
   * Image specific fields
   */
  steps?: number /* int */;
  count?: number /* int */;
  /**
   * Video specific fields
   */
  resolution?: VideoResolution;
  seconds?: number /* float64 */;
  fps?: number /* int */;
  /**
   * Audio specific fields
   */
  sample_rate?: number /* int */;
  /**
   * App-specific key-value pairs for custom pricing factors
   */
  extra?: { [key: string]: any};
}
/**
 * OutputMeta contains structured metadata about task inputs and outputs for pricing calculation
 */
export interface OutputMeta {
  inputs: MetaItem[];
  outputs: MetaItem[];
}
export interface UsageEvent extends BaseModel, PermissionModel {
  usage_billing_record_id: string;
  reference_id: string;
  resource_id: string;
  /**
   * Resource tier
   */
  tier: UsageEventResourceTier;
  type: string;
  model: string;
  quantity: number /* int64 */;
  unit: string;
}
/**
 * DiscountItem represents a single discount applied to a billing record
 */
export interface DiscountItem {
  reason: string; // e.g. "task_failed", "promotion", "support_credit"
  amount: number /* int64 */; // discount amount in microcents
}
export interface UsageBillingRecord extends BaseModel, PermissionModel {
  /**
   * Fee breakdown (all in microcents)
   */
  total: number /* int64 */;
  discount: number /* int64 */; // Total discount applied (sum of Discounts items)
  /**
   * User debit (total charged)
   */
  user_debit_transaction_id: string;
  user_debit_transaction?: Transaction;
  /**
   * Resource owner credit (for providing compute)
   */
  resource_credit_transaction_id: string;
  resource_credit_transaction?: Transaction;
  /**
   * Creator royalty credit (app creator earnings)
   */
  royalty_credit_transaction_id: string;
  royalty_credit_transaction?: Transaction;
  /**
   * Inference fee credit (platform fee)
   */
  inference_credit_transaction_id: string;
  inference_credit_transaction?: Transaction;
  /**
   * Partner fee credit (cloud API fee)
   */
  partner_credit_transaction_id: string;
  partner_credit_transaction?: Transaction;
}
export interface UsageBillingRefund extends BaseModel, PermissionModel {
  usage_billing_record_id: string;
  usage_billing_record?: UsageBillingRecord;
  /**
   * User refund (total refunded)
   */
  user_debit_refund_transaction_id: string;
  user_debit_refund_transaction?: Transaction;
  /**
   * Resource owner reversal
   */
  resource_credit_refund_transaction_id: string;
  resource_credit_refund_transaction?: Transaction;
  /**
   * Creator royalty reversal
   */
  royalty_credit_refund_transaction_id: string;
  royalty_credit_refund_transaction?: Transaction;
  /**
   * Inference fee reversal
   */
  inference_credit_refund_transaction_id: string;
  inference_credit_refund_transaction?: Transaction;
  /**
   * Partner fee reversal
   */
  partner_credit_refund_transaction_id: string;
  partner_credit_refund_transaction?: Transaction;
}

//////////
// source: user.go

/**
 * User-related types
 */
export interface User {
  BaseModel: BaseModel; // anonymous embedding
  default_team_id: string;
  role: Role;
  email: string;
  email_verified: boolean;
  name: string;
  full_name: string;
  avatar_url: string;
  metadata: UserMetadata;
}
export type Role = string;
export const RoleGuest: Role = "guest";
export const RoleUser: Role = "user";
export const RoleAdmin: Role = "admin";
export const RoleSystem: Role = "system";
export interface UserDTO extends BaseModel {
  default_team_id: string;
  role: Role;
  email: string;
  name: string;
  full_name: string;
  avatar_url: string;
  metadata: UserMetadata;
}
/**
 * User-related types
 */
export interface UserRelationDTO {
  id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  role: Role;
  avatar_url: string;
}
export interface UserMetadata {
  user_id: string;
  completed_onboarding: boolean;
  use_case: string;
  use_case_reason: string;
  use_case_privacy: string;
}

//////////
// source: widget.go

/**
 * WidgetAction represents an action triggered by a widget button
 */
export interface WidgetAction {
  type: string;
  payload?: { [key: string]: any};
}
/**
 * WidgetActionButton represents a button in a widget's action bar
 */
export interface WidgetActionButton {
  label: string;
  action: WidgetAction;
  variant?: string; // "default" | "secondary" | "outline" | "ghost" | "destructive"
}
/**
 * WidgetNodeType constants
 * Primitives (literal values): text, markdown, image, badge, button, input, select, checkbox, row, col
 * Data-bound (read from ToolInvocation.Data): plan-list, key-value, status-badge
 */
export type WidgetNodeType = string;
/**
 * Primitive node types (render literal values)
 */
export const WidgetNodeTypeText: WidgetNodeType = "text";
export const WidgetNodeTypeMarkdown: WidgetNodeType = "markdown";
export const WidgetNodeTypeImage: WidgetNodeType = "image";
export const WidgetNodeTypeBadge: WidgetNodeType = "badge";
export const WidgetNodeTypeButton: WidgetNodeType = "button";
export const WidgetNodeTypeInput: WidgetNodeType = "input";
export const WidgetNodeTypeSelect: WidgetNodeType = "select";
export const WidgetNodeTypeCheckbox: WidgetNodeType = "checkbox";
export const WidgetNodeTypeRow: WidgetNodeType = "row";
export const WidgetNodeTypeCol: WidgetNodeType = "col";
/**
 * Layout node types
 */
export const WidgetNodeTypeBox: WidgetNodeType = "box";
export const WidgetNodeTypeSpacer: WidgetNodeType = "spacer";
export const WidgetNodeTypeDivider: WidgetNodeType = "divider";
export const WidgetNodeTypeForm: WidgetNodeType = "form";
/**
 * Typography node types
 */
export const WidgetNodeTypeTitle: WidgetNodeType = "title";
export const WidgetNodeTypeCaption: WidgetNodeType = "caption";
export const WidgetNodeTypeLabel: WidgetNodeType = "label";
/**
 * Control node types
 */
export const WidgetNodeTypeTextarea: WidgetNodeType = "textarea";
export const WidgetNodeTypeRadioGroup: WidgetNodeType = "radio-group";
export const WidgetNodeTypeDatePicker: WidgetNodeType = "date-picker";
/**
 * Content node types
 */
export const WidgetNodeTypeIcon: WidgetNodeType = "icon";
export const WidgetNodeTypeChart: WidgetNodeType = "chart";
export const WidgetNodeTypeTransition: WidgetNodeType = "transition";
/**
 * Data-bound node types (deprecated - use templates instead)
 */
export const WidgetNodeTypePlanList: WidgetNodeType = "plan-list";
export const WidgetNodeTypeKeyValue: WidgetNodeType = "key-value";
export const WidgetNodeTypeStatusBadge: WidgetNodeType = "status-badge";
/**
 * WidgetNode represents a UI element in a widget (text, input, select, etc.)
 */
export interface WidgetNode {
  type: WidgetNodeType;
  value?: string;
  src?: string;
  alt?: string;
  label?: string;
  name?: string;
  placeholder?: string;
  defaultValue?: string;
  variant?: string;
  action?: WidgetAction;
  options?: WidgetSelectOption[];
  defaultChecked?: boolean;
  children?: WidgetNode[];
  gap?: number /* int */;
  /**
   * Layout props (Box, Row, Col, Form)
   */
  align?: string; // start|center|end|baseline|stretch
  justify?: string; // start|center|end|between|around|evenly
  padding?: any; // number or {top,right,bottom,left}
  background?: any; // string or {light,dark}
  radius?: string; // 2xs|xs|sm|md|lg|xl|2xl|full|none
  direction?: string; // row|col (for Form)
  wrap?: string; // nowrap|wrap|wrap-reverse
  flex?: any; // string|number
  /**
   * Typography props (Text, Title, Caption, Label)
   */
  size?: string; // xs|sm|md|lg|xl|2xl|3xl
  weight?: string; // normal|medium|semibold|bold
  color?: any; // string or {light,dark}
  textAlign?: string; // start|center|end
  truncate?: boolean;
  maxLines?: number /* int */;
  /**
   * Control props (Input, Textarea, Select, Checkbox, RadioGroup, DatePicker, Button)
   */
  disabled?: boolean;
  required?: boolean;
  rows?: number /* int */; // for Textarea
  fieldName?: string; // for Label
  submit?: boolean; // for Button - makes it a form submit button
  pattern?: string; // for Input - regex validation
  min?: string; // for DatePicker - min date
  max?: string; // for DatePicker - max date
  clearable?: boolean; // for Select/DatePicker
  /**
   * Action handler for buttons (form data is collected locally and sent with action)
   */
  onClickAction?: WidgetAction; // for Button
  /**
   * Content props (Icon, Spacer, Divider, Chart)
   */
  iconName?: string; // for Icon
  spacing?: any; // for Divider
  minSize?: any; // for Spacer
  height?: any; // number or string
  width?: any; // number or string
  /**
   * Chart specific props
   */
  chartData?: any; // []map[string]interface{}
  chartSeries?: any; // []ChartSeries
  xAxis?: any; // string or XAxisConfig
  showYAxis?: boolean;
  showLegend?: boolean;
  showTooltip?: boolean;
  /**
   * Form-specific props
   */
  onSubmitAction?: WidgetAction; // for Form
  /**
   * Data binding (deprecated - use templates instead)
   */
  dataKey?: string;
}
/**
 * WidgetSelectOption represents an option in a select widget
 */
export interface WidgetSelectOption {
  label: string;
  value: string;
}
/**
 * Widget represents an interactive widget for display in chat
 * Type is either "ui" (structured nodes) or "html" (raw HTML)
 * For "ui" widgets, data-bound nodes read values from ToolInvocation.Data
 */
export interface Widget {
  type: string; // "ui" | "html"
  interactive?: boolean;
  title?: string;
  html?: string; // For type="html"
  json?: string; // Original JSON for reference
  children?: WidgetNode[];
  actions?: WidgetActionButton[];
}
