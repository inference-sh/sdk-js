// Code generated by tygo. DO NOT EDIT.

//////////
// source: agent.go

/**
 * InternalToolsConfig controls which built-in tools are enabled for an agent
 */
export interface InternalToolsConfig {
  plan?: boolean; // Plan tools (Create, Update, Load) - default: true
  memory?: boolean; // Memory tools (Set, Get, GetAll) - default: true
  widget?: boolean; // Widget tools (UI, HTML) - default: true, top-level only
  finish?: boolean; // Finish tool - default: true (sub-agents only)
}
/**
 * ToolType represents the type of tool (used in both AgentTool definition and ToolInvocation)
 */
export type ToolType = string;
export const ToolTypeApp: ToolType = "app"; // App tools - creates a Task
export const ToolTypeAgent: ToolType = "agent"; // Sub-agent tools - creates a sub-Chat
export const ToolTypeHook: ToolType = "hook"; // Webhook tools - HTTP POST to external URL
export const ToolTypeClient: ToolType = "client"; // Client tools - executed by frontend
export const ToolTypeInternal: ToolType = "internal"; // Internal/built-in tools (plan, memory, widget, finish)
/**
 * AppToolConfig contains configuration for an app tool
 */
export interface AppToolConfig {
  /**
   * Ref is the human-readable reference: "namespace/name@shortVersionId"
   * This is what users specify in configs/SDKs
   */
  ref: string;
  /**
   * ID and VersionID are resolved full database UUIDs (populated at runtime)
   */
  id?: string;
  version_id?: string;
  /**
   * Resolved app object (populated at runtime)
   */
  app?: App;
}
/**
 * AgentToolConfig contains configuration for a sub-agent tool
 */
export interface AgentToolConfig {
  /**
   * Ref is the human-readable reference: "namespace/name@shortVersionId"
   * This is what users specify in configs/SDKs
   */
  ref: string;
  /**
   * ID and VersionID are resolved full database UUIDs (populated at runtime)
   */
  id?: string;
  version_id?: string;
  /**
   * Resolved agent object (populated at runtime)
   */
  agent?: Agent;
}
/**
 * HookToolConfig contains configuration for a webhook tool
 */
export interface HookToolConfig {
  url: string;
  secret?: string;
  input_schema?: any;
  output_schema?: any;
}
/**
 * ClientToolConfig contains configuration for a frontend-executed tool
 */
export interface ClientToolConfig {
  input_schema?: any;
  output_schema?: any;
}
/**
 * AgentTool represents a unified tool that can be used by an agent
 */
export interface AgentTool {
  name: string;
  display_name?: string;
  description: string;
  type: ToolType;
  /**
   * Human-in-the-Loop: if true, tool execution requires user approval
   */
  require_approval?: boolean;
  /**
   * Type-specific config (exactly one should be set based on Type)
   */
  app?: AppToolConfig;
  agent?: AgentToolConfig;
  hook?: HookToolConfig;
  client?: ClientToolConfig;
  internal?: InternalToolConfig;
}
/**
 * InternalToolConfig contains configuration for internal/built-in tools
 */
export interface InternalToolConfig {
  category: string; // plan, memory, widget, finish
  operation: string; // create, update, load, set, get, ui, html, etc.
}
/**
 * AgentToolDTO for API responses
 */
export interface AgentToolDTO {
  name: string;
  display_name?: string;
  description: string;
  type: ToolType;
  /**
   * Human-in-the-Loop: if true, tool execution requires user approval
   */
  require_approval?: boolean;
  app?: AppToolConfigDTO;
  agent?: AgentToolConfigDTO;
  hook?: HookToolConfigDTO;
  client?: ClientToolConfigDTO;
}
export interface AppToolConfigDTO {
  ref: string;
  id?: string;
  version_id?: string;
  app?: AppDTO;
}
export interface AgentToolConfigDTO {
  ref: string;
  id?: string;
  version_id?: string;
  agent?: AgentDTO;
}
export interface HookToolConfigDTO {
  url: string;
  secret?: string;
  input_schema?: any;
  output_schema?: any;
}
export interface ClientToolConfigDTO {
  input_schema?: any;
  output_schema?: any;
}
/**
 * CoreAppConfig references an app used as the agent's core
 */
export interface CoreAppConfig {
  id: string;
  version_id: string;
  app?: App;
}
export interface Agent {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  ProjectModel: ProjectModel;
  /**
   * Basic info
   */
  namespace: string;
  name: string;
  version_id: string;
  version?: AgentVersion;
}
/**
 * AgentDTO for API responses
 */
export interface AgentDTO extends BaseModel, PermissionModelDTO, ProjectModelDTO {
  namespace: string;
  name: string;
  version_id: string;
  version?: AgentVersionDTO;
}
export interface AgentVersion {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  agent_id: string;
  description: string;
  system_prompt: string;
  example_prompts: string[];
  core_app?: CoreAppConfig;
  core_app_input?: any;
  /**
   * Unified tools array (apps, agents, hooks)
   */
  tools: (AgentTool | undefined)[];
  /**
   * Internal tools configuration (plan, memory, widget, finish)
   */
  internal_tools?: InternalToolsConfig;
  /**
   * Output schema for custom finish tool (sub-agents only)
   */
  output_schema?: any;
}
export interface CoreAppConfigDTO {
  id: string;
  version_id: string;
  app?: AppDTO;
}
export interface AgentVersionDTO extends BaseModel, PermissionModelDTO {
  description: string;
  system_prompt: string;
  example_prompts: string[];
  core_app?: CoreAppConfigDTO;
  core_app_input?: any;
  /**
   * Unified tools array (apps, agents, hooks, client)
   */
  tools: (AgentToolDTO | undefined)[];
  /**
   * Internal tools configuration (plan, memory, widget, finish)
   */
  internal_tools?: InternalToolsConfig;
  /**
   * Output schema for custom finish tool (sub-agents only)
   */
  output_schema?: any;
}
/**
 * AgentRuntimeConfig is a self-contained, flattened config for chat execution.
 * This is either snapshotted from an Agent template or provided ad-hoc.
 * It's portable and can be serialized to JSON or YAML.
 */
export interface AgentRuntimeConfig {
  /**
   * Origin tracking (optional, for lineage when snapshotted from template)
   */
  agent_id?: string;
  agent_version_id?: string;
  /**
   * Identity
   */
  name: string;
  namespace?: string;
  description?: string;
  /**
   * Prompts
   */
  system_prompt: string;
  example_prompts?: string[];
  /**
   * Core LLM
   * CoreAppRef is the user-facing ref (namespace/name@shortid) - used in ad-hoc configs
   * CoreApp is the resolved config - populated by backend after resolving CoreAppRef
   */
  core_app_ref?: string;
  core_app?: CoreAppConfig;
  core_app_input?: any;
  /**
   * Tools (apps, agents, hooks, client tools)
   */
  tools?: (AgentTool | undefined)[];
  /**
   * Internal tools configuration (plan, memory, widget, finish)
   */
  internal_tools?: InternalToolsConfig;
  /**
   * Output schema for custom finish tool (sub-agents only)
   */
  output_schema?: any;
}
/**
 * AgentRuntimeConfigDTO for API responses
 */
export interface AgentRuntimeConfigDTO {
  agent_id?: string;
  agent_version_id?: string;
  name: string;
  namespace?: string;
  description?: string;
  system_prompt: string;
  example_prompts?: string[];
  core_app_ref?: string;
  core_app?: CoreAppConfigDTO;
  core_app_input?: any;
  tools?: (AgentToolDTO | undefined)[];
  internal_tools?: InternalToolsConfig;
  output_schema?: any;
}

//////////
// source: api.go

export interface APIRequest<T extends any> {
  timestamp: string /* RFC3339 */;
  data: T;
}
export interface APIResponse<T extends any> {
  success: boolean;
  status: number /* int */;
  data?: T;
  error?: APIError;
}
export interface APIError {
  code: string;
  message: string;
}
/**
 * ApiAppRunRequest is the request body for /apps/run endpoint.
 * Version pinning is required for stability.
 */
export interface ApiAppRunRequest {
  /**
   * App reference in format: namespace/name@shortid (version required)
   * Example: "okaris/flux@abc1"
   * The short ID ensures your code always runs the same version.
   */
  app: string;
  /**
   * Deprecated: Use namespace/name@shortid format in App field instead.
   */
  version?: string;
  infra?: Infra;
  workers?: string[];
  webhook?: string;
  setup?: any;
  input: any;
  /**
   * If true, returns SSE stream instead of JSON response
   */
  stream?: boolean;
}
/**
 * ApiTaskRequest is an alias for ApiAppRunRequest (deprecated name)
 */
export type ApiTaskRequest = ApiAppRunRequest;
/**
 * ApiAgentRunRequest is the request body for /agents/run endpoint.
 * Supports both template agents and ad-hoc agents.
 */
export interface ApiAgentRunRequest {
  /**
   * Existing chat ID to continue a conversation (optional)
   */
  chat_id?: string;
  /**
   * Template agent reference in format: namespace/name@shortid
   * Example: "my-org/assistant@abc123"
   * Use this OR AgentConfig, not both
   */
  agent?: string;
  /**
   * Ad-hoc agent configuration
   * For ad-hoc agents, set core_app_ref to the LLM app reference
   * Example: { "core_app_ref": "infsh/claude-sonnet-4@abc123", "system_prompt": "..." }
   */
  agent_config?: AgentRuntimeConfig;
  /**
   * The message to send
   */
  input: ChatTaskInput;
  /**
   * If true, returns SSE stream instead of JSON response
   */
  stream?: boolean;
}
/**
 * ApiAgentMessageRequest is an alias for ApiAgentRunRequest (deprecated name)
 */
export type ApiAgentMessageRequest = ApiAgentRunRequest;
export interface CreateAgentMessageRequest {
  chat_id?: string;
  agent_id?: string; // Deprecated: use Agent instead
  agent_version_id?: string; // Deprecated: use Agent instead
  agent?: string; // Template agent: namespace/name@shortid
  tool_call_id?: string;
  input: ChatTaskInput;
  integration_context?: IntegrationContext;
  /**
   * Ad-hoc agent config - use this instead of Agent for embedded configs
   * If provided, creates a chat with this config directly (no agent reference)
   */
  agent_config?: AgentRuntimeConfig;
}
export interface CreateChatMessageResponse {
  user_message?: ChatMessageDTO;
  assistant_message?: ChatMessageDTO;
}
/**
 * ToolResultRequest represents a tool result submission
 * For widget actions, clients should JSON-serialize { action, form_data } as the result string
 */
export interface ToolResultRequest {
  result: string;
}
/**
 * HookPayload represents the request body sent to a webhook when a hook tool is invoked
 */
export interface HookPayload {
  /**
   * Identification
   */
  tool_invocation_id: string;
  hook_name: string;
  /**
   * Callback - use this to submit the result back
   */
  callback_url: string;
  callback_method: string; // Always "POST"
  /**
   * Timestamp in RFC3339 format
   */
  timestamp: string;
  /**
   * The actual tool arguments from the LLM
   */
  arguments: { [key: string]: any};
}
/**
 * HookResponse represents the expected response from the hook URL
 * The hook should return 200 with success:true to acknowledge receipt
 * The actual result should be sent via the callback URL
 */
export interface HookResponse {
  success: boolean;
  message?: string;
}
export interface PartialFile {
  uri: string;
  path?: string;
  content_type?: string;
  size?: number /* int64 */;
  filename?: string;
}
export interface FileCreateRequest {
  files: PartialFile[];
}
export interface CreateFlowRequest {
  name: string;
}
export interface CreateFlowRunRequest {
  flow: string;
  input: any;
}
export interface CheckoutCreateRequest {
  amount: number /* int64 */;
  success_url: string;
  cancel_url: string;
}
export interface CheckoutCompleteRequest {
  session_id: string;
}
/**
 * Legacy aliases for backward compatibility
 */
export type StripeCheckoutCreateRequest = CheckoutCreateRequest;
export type StripeCheckoutCompleteRequest = CheckoutCompleteRequest;
/**
 * DeviceAuthResponse is returned when a device initiates auth
 */
export interface DeviceAuthResponse {
  user_code: string; // The code to show the user
  device_code: string; // The code for polling
  poll_url: string; // URL to poll for status
  approve_url: string; // URL for user to visit
  expires_in: number /* int */; // Seconds until expiration
  interval: number /* int */; // Recommended polling interval in seconds
}
/**
 * DeviceAuthPollResponse is returned when polling for auth status
 */
export interface DeviceAuthPollResponse {
  status: DeviceAuthStatus; // pending, approved, expired, denied
  api_key?: string; // Only set when status is approved
  team_id?: string; // Only set when status is approved
}
/**
 * DeviceAuthApproveRequest is sent when user approves the auth request
 */
export interface DeviceAuthApproveRequest {
  code: string; // The user_code
  team_id: string; // The team to associate the API key with
}
/**
 * DeviceAuthApproveResponse is returned after approval
 */
export interface DeviceAuthApproveResponse {
  success: boolean;
  message?: string;
}
/**
 * DeviceAuthCodeInfo contains info about a pending auth code (for display on approve page)
 */
export interface DeviceAuthCodeInfo {
  user_code: string;
  expires_at: string /* RFC3339 */;
  valid: boolean;
  status: DeviceAuthStatus; // pending, approved, expired
}
/**
 * MeResponse is returned from GET /me with user and current team info
 */
export interface MeResponse {
  user?: UserDTO;
  team?: TeamDTO;
}
export interface TeamCreateRequest {
  name: string;
  username: string;
  email: string;
}
/**
 * TeamSetupRequest is used for completing team setup (choosing username)
 * This marks the team as setup_completed=true after validation
 */
export interface TeamSetupRequest {
  username: string;
}
export interface TeamMemberAddRequest {
  email: string;
  role: TeamRole;
}
export interface TeamMemberUpdateRoleRequest {
  role: TeamRole;
}
/**
 * SecretCreateRequest for creating a new secret
 */
export interface SecretCreateRequest {
  key: string;
  value: string;
  description?: string;
}
/**
 * SecretUpdateRequest for updating a secret value
 */
export interface SecretUpdateRequest {
  value: string;
  description?: string; // Pointer to allow unsetting
}
/**
 * IntegrationConnectRequest for initiating an integration connection
 */
export interface IntegrationConnectRequest {
  provider: string;
  type: string;
  scopes?: string[];
  /**
   * For API Key type
   */
  api_key?: string;
  /**
   * For BYOK integrations (e.g., X.com) - contains user-provided credentials
   */
  metadata?: { [key: string]: any};
}
/**
 * IntegrationCompleteOAuthRequest for completing an OAuth flow
 */
export interface IntegrationCompleteOAuthRequest {
  provider: string;
  type: string;
  code: string;
  state: string;
  /**
   * For PKCE - code_verifier to complete the exchange (required by some providers like X/Twitter)
   */
  code_verifier?: string;
}
/**
 * IntegrationConnectResponse after connecting
 */
export interface IntegrationConnectResponse {
  integration?: IntegrationDTO;
  /**
   * For OAuth - redirect URL to start the flow
   */
  auth_url?: string;
  /**
   * For OAuth - state to be returned with the callback (frontend stores this)
   */
  state?: string;
  /**
   * For PKCE - code_verifier to be stored and sent back with CompleteOAuth (required by some providers like X/Twitter)
   */
  code_verifier?: string;
  /**
   * For service accounts - instructions
   */
  instructions?: string;
}
export interface ProjectCreateRequest {
  name: string;
  type: ProjectType;
}
export interface ProjectUpdateRequest {
  name: string;
}
export interface MoveAgentToProjectRequest {
  agent_id: string;
  project_id: string;
}

//////////
// source: app.go

export type AppCategory = string;
export const AppCategoryImage: AppCategory = "image";
export const AppCategoryVideo: AppCategory = "video";
export const AppCategoryAudio: AppCategory = "audio";
export const AppCategoryText: AppCategory = "text";
export const AppCategoryChat: AppCategory = "chat";
export const AppCategory3D: AppCategory = "3d";
export const AppCategoryOther: AppCategory = "other";
export const AppCategoryFlow: AppCategory = "flow";
export type GPUType = string;
export const GPUTypeAny: GPUType = "any";
export const GPUTypeNone: GPUType = "none";
export const GPUTypeIntel: GPUType = "intel";
export const GPUTypeNvidia: GPUType = "nvidia";
export const GPUTypeAMD: GPUType = "amd";
export const GPUTypeApple: GPUType = "apple";
export interface AppImages {
  card: string;
  thumbnail: string;
  banner: string;
}
export interface App {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  /**
   * Namespace is copied from team.username at creation time and is IMMUTABLE.
   * This ensures stable references like "namespace/name" even if team username changes.
   * Default empty string allows GORM migration to add column, then MigrateAppNamespaces populates it.
   */
  namespace: string;
  /**
   * Name is IMMUTABLE after creation. Combined with Namespace forms unique identifier.
   */
  name: string;
  description: string;
  agent_description: string;
  /**
   * Category is a fundamental classification of the app (image, video, audio, text, chat, 3d, other)
   */
  category: AppCategory;
  /**
   * Developer's images
   */
  images: AppImages;
  /**
   * Current version (developer's latest)
   */
  version_id: string;
  version?: AppVersion;
}
export interface AppGPUResource {
  count: number /* int */;
  vram: number /* int64 */;
  type: GPUType;
}
export interface AppResources {
  gpu: AppGPUResource;
  ram: number /* int */;
}
export interface AppVariant {
  name: string;
  order: number /* int */;
  resources: AppResources;
  env: { [key: string]: string};
  python: string;
}
/**
 * AppFunction represents a callable entry point within an app version.
 * Each function has its own input/output schema while sharing the app's setup.
 */
export interface AppFunction {
  name: string;
  description?: string;
  input_schema: any;
  output_schema: any;
}
export interface AppVersion {
  BaseModel: BaseModel;
  /**
   * ShortID is a human-friendly version identifier (e.g., "abc123")
   * Unique within the app, used in references like "namespace/app@abc123"
   */
  short_id: string;
  app_id: string;
  metadata: { [key: string]: any};
  repository: string;
  flow_id?: string;
  flow?: Flow;
  setup_schema: any;
  input_schema: any;
  output_schema: any;
  /**
   * Functions contains the callable entry points for this app version.
   * Each function has its own input/output schema. If nil/empty, the app uses legacy single-function mode
   * with InputSchema/OutputSchema at the version level.
   */
  functions?: { [key: string]: AppFunction};
  default_function?: string;
  variants: { [key: string]: AppVariant};
  env: { [key: string]: string};
  kernel: string;
  /**
   * App requirements - secrets and integrations needed to run this app
   */
  required_secrets?: SecretRequirement[];
  required_integrations?: IntegrationRequirement[];
  resources: AppResources;
}
export interface AppDTO extends BaseModel, PermissionModelDTO {
  namespace: string;
  name: string;
  description: string;
  agent_description: string;
  category: AppCategory;
  images: AppImages;
  version_id: string;
  version?: AppVersionDTO;
}
export interface AppVersionDTO extends BaseModel {
  short_id: string;
  metadata: { [key: string]: any};
  repository: string;
  flow?: FlowDTO;
  setup_schema: any;
  input_schema: any;
  output_schema: any;
  functions?: { [key: string]: AppFunction};
  default_function?: string;
  variants: { [key: string]: AppVariant};
  env: { [key: string]: string};
  kernel: string;
  /**
   * App requirements
   */
  required_secrets?: SecretRequirement[];
  required_integrations?: IntegrationRequirement[];
  resources: AppResources;
}

//////////
// source: base.go

export interface BaseModel {
  id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  deleted_at?: string /* RFC3339 */;
}
/**
 * Visibility represents the visibility level of a resource
 */
export type Visibility = string;
export const VisibilityPrivate: Visibility = "private";
export const VisibilityPublic: Visibility = "public";
export const VisibilityUnlisted: Visibility = "unlisted";
export interface PermissionModel {
  user_id: string;
  user?: User;
  team_id: string;
  team?: Team;
  visibility: Visibility;
}
export interface PermissionModelDTO {
  user_id: string;
  user?: UserRelationDTO;
  team_id: string;
  team?: TeamRelationDTO;
  visibility: Visibility;
}

//////////
// source: chat.go

export type ChatStatus = string;
export const ChatStatusBusy: ChatStatus = "busy";
export const ChatStatusIdle: ChatStatus = "idle";
export const ChatStatusAwaitingInput: ChatStatus = "awaiting_input";
export const ChatStatusCompleted: ChatStatus = "completed";
export interface IntegrationContext {
  integration_type?: IntegrationType;
  integration_metadata?: any;
}
/**
 * ChatData contains agent-specific data for a chat session
 */
export interface ChatData {
  plan_steps: PlanStep[];
  memory: StringEncodedMap;
  always_allowed_tools: string[];
}
/**
 * PlanStep represents a step in an agent's execution plan
 */
export interface PlanStep {
  index: number /* int */;
  title: string;
  description: string;
  notes?: string;
  status: PlanStepStatus;
}
/**
 * PlanStepStatus represents the status of a plan step
 */
export type PlanStepStatus = string;
export const PlanStepStatusPending: PlanStepStatus = "pending";
export const PlanStepStatusInProgress: PlanStepStatus = "in_progress";
export const PlanStepStatusCompleted: PlanStepStatus = "completed";
export const PlanStepStatusCancelled: PlanStepStatus = "cancelled";
export type ChatMessageRole = string;
export const ChatMessageRoleSystem: ChatMessageRole = "system";
export const ChatMessageRoleUser: ChatMessageRole = "user";
export const ChatMessageRoleAssistant: ChatMessageRole = "assistant";
export const ChatMessageRoleTool: ChatMessageRole = "tool";
/**
 * ChatMessageStatus represents the lifecycle status of a chat message
 */
export type ChatMessageStatus = string;
export const ChatMessageStatusPending: ChatMessageStatus = "pending"; // Message is being generated
export const ChatMessageStatusReady: ChatMessageStatus = "ready"; // Message complete, tools ready for execution
export const ChatMessageStatusFailed: ChatMessageStatus = "failed"; // Message generation failed
export const ChatMessageStatusCancelled: ChatMessageStatus = "cancelled"; // Message was cancelled
export type ChatMessageContentType = string;
export const ChatMessageContentTypeText: ChatMessageContentType = "text";
export const ChatMessageContentTypeReasoning: ChatMessageContentType = "reasoning";
export const ChatMessageContentTypeImage: ChatMessageContentType = "image";
export const ChatMessageContentTypeFile: ChatMessageContentType = "file";
export const ChatMessageContentTypeTool: ChatMessageContentType = "tool";
export type IntegrationType = string;
export const IntegrationTypeSlack: IntegrationType = "slack";
export const IntegrationTypeDiscord: IntegrationType = "discord";
export const IntegrationTypeTeams: IntegrationType = "teams";
export const IntegrationTypeTelegram: IntegrationType = "telegram";
export interface ChatMessageContent {
  type: ChatMessageContentType;
  error?: string;
  text?: string;
  image?: string;
  file?: string;
  tool_calls?: ToolCall[];
}
/**
 * ToolCall represents a tool call from an LLM response (wire format)
 * This is a transport object for parsing LLM responses, not a database model
 */
export interface ToolCall {
  id: string;
  type: string; // "function"
  function: ToolCallFunction;
}
/**
 * ToolCallFunction contains the function name and arguments from an LLM tool call
 */
export interface ToolCallFunction {
  name: string;
  arguments: StringEncodedMap;
}
export interface ChatTaskInput {
  model?: string;
  context_size: number /* int */;
  temperature?: number /* float64 */;
  top_p?: number /* float64 */;
  reasoning_effort?: string;
  reasoning_max_tokens?: number /* int */;
  system_prompt: string;
  context: ChatTaskContextMessage[];
  role: ChatMessageRole;
  text?: string;
  reasoning?: string;
  image?: string;
  images?: string[];
  files?: string[];
  tools?: Tool[];
  tool_call_id?: string;
}
export interface ChatTaskContextMessage {
  role: ChatMessageRole;
  text?: string;
  reasoning?: string;
  image?: string;
  images?: string[];
  file?: string;
  files?: string[];
  tools?: Tool[];
  tool_calls?: ToolCall[];
  tool_call_id?: string;
}
export interface ChatDTO extends BaseModel, PermissionModelDTO {
  parent_id?: string;
  parent?: ChatDTO;
  children: (ChatDTO | undefined)[];
  status: ChatStatus;
  agent_config?: AgentRuntimeConfigDTO;
  name: string;
  description: string;
  chat_messages: ChatMessageDTO[];
  agent_data: ChatData;
}
export interface ChatMessageDTO extends BaseModel, PermissionModelDTO {
  chat_id: string;
  chat?: ChatDTO;
  order: number /* int */;
  status: ChatMessageStatus;
  task_id?: string;
  role: ChatMessageRole;
  content: ChatMessageContent[];
  tools?: Tool[];
  tool_call_id?: string;
  tool_invocations?: ToolInvocationDTO[];
}

//////////
// source: common.go

export type StringEncodedMap = { [key: string]: any};

//////////
// source: deviceauth.go

export type DeviceAuthStatus = string;
export const DeviceAuthStatusPending: DeviceAuthStatus = "pending";
export const DeviceAuthStatusApproved: DeviceAuthStatus = "approved";
export const DeviceAuthStatusExpired: DeviceAuthStatus = "expired";
export const DeviceAuthStatusDenied: DeviceAuthStatus = "denied";
export const DeviceAuthStatusValid: DeviceAuthStatus = "valid";
export const DeviceAuthStatusInvalid: DeviceAuthStatus = "invalid";
export const DeviceAuthStatusLoading: DeviceAuthStatus = "loading";

//////////
// source: engine.go

/**
 * Engine-related types
 */
export type EngineStatus = string;
export const EngineStatusRunning: EngineStatus = "running";
export const EngineStatusPending: EngineStatus = "pending";
export const EngineStatusStopping: EngineStatus = "stopping";
export const EngineStatusStopped: EngineStatus = "stopped";
export interface EngineStateSummary extends BaseModel, PermissionModelDTO {
  instance?: Instance;
  name: string;
  status: EngineStatus;
  workers: (WorkerStateSummary | undefined)[];
}
/**
 * Worker-related types
 */
export type WorkerStatus = string;
export interface WorkerGPU {
  id: string;
  worker_id: string;
  gpu_id: string;
  type: GPUType;
  name: string;
  vram: number /* int64 */;
}
export interface WorkerCPU {
  id: string;
  worker_id: string;
  name: string;
  vendor_id: string;
  family: string;
  model: string;
  cores: number /* int */;
  frequency: string;
}
export interface WorkerRAM {
  id: string;
  worker_id: string;
  total: number /* uint64 */;
}
export interface WorkerStateSummary {
  id: string;
  user_id: string;
  index: number /* int */;
  status: WorkerStatus;
  engine_id: string;
  engine_name: string;
  task_id?: string;
  app_id: string;
  app_version_id: string;
  gpus: WorkerGPU[];
  cpus: WorkerCPU[];
  rams: WorkerRAM[];
}

//////////
// source: file.go

export interface File {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  path: string;
  remote_path: string;
  upload_url: string;
  uri: string;
  content_type: string;
  size: number /* int64 */;
  filename: string;
  rating: ContentRating;
}
export interface FileDTO extends BaseModel, PermissionModelDTO {
  path: string;
  remote_path: string;
  upload_url: string;
  uri: string;
  content_type: string;
  size: number /* int64 */;
  filename: string;
  rating: ContentRating;
}

//////////
// source: flow.go

export interface Flow {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  name: string;
  description: string;
  card_image: string;
  thumbnail: string;
  banner_image: string;
  input_schema: any;
  input: FlowRunInputs;
  output_schema: any;
  output_mappings: OutputMappings;
  node_data: FlowNodeDataMap;
  nodes: FlowNode[];
  edges: FlowEdge[];
  viewport?: FlowViewport;
}
export interface FlowViewport {
  x: number /* float64 */;
  y: number /* float64 */;
  zoom: number /* float64 */;
}
export interface FlowNode {
  id: string;
  type: string;
  position: FlowNodePosition;
}
export interface FlowNodePosition {
  x: number /* float64 */;
  y: number /* float64 */;
}
export interface FlowNodeData {
  app?: AppDTO;
  app_id: string;
  app_version_id: string;
  function?: string; // Function to call on multi-function apps (defaults to version's default)
  infra: Infra;
  workers: string[];
  setup?: any;
  additional?: any;
  task?: TaskDTO;
  task_id?: string;
}
export type FlowNodeDataMap = { [key: string]: FlowNodeData};
export interface FlowEdge {
  id: string;
  type: string;
  source: string;
  target: string;
  source_handle?: string;
  target_handle?: string;
}
/**
 * OutputFieldMapping represents a mapping from a source node's field to an output field in the flow output schema.
 */
export interface OutputFieldMapping {
  sourceNodeId: string;
  sourceFieldPath: string;
  outputFieldName: string;
  type: string;
  schema: any;
}
/**
 * OutputMappings is a map of output field name to OutputFieldMapping.
 */
export type OutputMappings = { [key: string]: OutputFieldMapping};
export interface FlowDTO extends BaseModel, PermissionModelDTO {
  name: string;
  description: string;
  card_image: string;
  thumbnail: string;
  banner_image: string;
  input_schema: any;
  input: FlowRunInputs;
  output_schema: any;
  output_mappings: OutputMappings;
  node_data: FlowNodeDataMap;
  nodes: FlowNode[];
  edges: FlowEdge[];
  viewport?: FlowViewport;
}
/**
 * Connection represents a connection between nodes in a flow
 */
export interface FlowNodeConnection {
  nodeId: string;
  key: string;
  type: string;
  previousValue: any;
}
export type FlowRunInputs = { [key: string]: { [key: string]: FlowRunInput}};
export interface FlowRunInput {
  Connection?: FlowNodeConnection;
  Value: any;
}

//////////
// source: integration.go

/**
 * StringSlice is a custom type for storing string slices in the database
 */
export type StringSlice = string[];
/**
 * IntegrationDTO for API responses (never exposes tokens)
 */
export interface IntegrationDTO extends BaseModel, PermissionModelDTO {
  provider: string;
  type: string;
  status: string;
  display_name: string;
  scopes: StringSlice;
  expires_at?: string /* RFC3339 */;
  service_account_email?: string;
  metadata?: { [key: string]: any};
  account_identifier?: string; // e.g., email for Google, @username for X
  account_name?: string; // Display name of connected account
  is_primary: boolean; // Default account for this provider:type (for future multi-account support)
  error_message?: string;
}

//////////
// source: project.go

/**
 * ProjectType represents different types of projects
 */
export type ProjectType = string;
export const ProjectTypeAgent: ProjectType = "agent";
export const ProjectTypeApp: ProjectType = "app";
export const ProjectTypeFlow: ProjectType = "flow";
export const ProjectTypeOther: ProjectType = "other";
/**
 * ProjectModel provides optional project association for models
 */
export interface ProjectModel {
  project_id?: string;
  project?: Project;
}
export interface ProjectModelDTO {
  project_id?: string;
  project?: ProjectDTO;
}
/**
 * Project represents a container for organizing related resources
 */
export interface Project {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  name: string;
  description: string;
  type: ProjectType;
  color?: string;
  icon?: string;
  /**
   * For future: nested folders/projects
   */
  parent_id?: string;
  parent?: Project;
  children: (Project | undefined)[];
}
/**
 * ProjectDTO for API responses
 */
export interface ProjectDTO extends BaseModel, PermissionModelDTO {
  name: string;
  description: string;
  type: ProjectType;
  color?: string;
  icon?: string;
  parent_id?: string;
  parent?: ProjectDTO;
  children: (ProjectDTO | undefined)[];
}

//////////
// source: rating.go

export type ContentRating = string;
export const ContentSafe: ContentRating = "safe";
/**
 * sexual content
 */
export const ContentSexualSuggestive: ContentRating = "sexual_suggestive";
export const ContentSexualExplicit: ContentRating = "sexual_explicit";
/**
 * violence
 */
export const ContentViolenceNonGraphic: ContentRating = "violence_non_graphic";
export const ContentViolenceGraphic: ContentRating = "violence_graphic";
/**
 * gore
 */
export const ContentGore: ContentRating = "gore";
/**
 * other regulated content
 */
export const ContentDrugs: ContentRating = "drugs";
export const ContentSelfHarm: ContentRating = "self_harm";
export const ContentUnrated: ContentRating = "unrated";

//////////
// source: requirements.go

/**
 * SecretRequirement defines a secret that an app requires to run
 */
export interface SecretRequirement {
  key: string;
  description?: string;
  optional?: boolean;
}
/**
 * IntegrationRequirement defines an integration capability that an app requires
 */
export interface IntegrationRequirement {
  key: string; // e.g., "google.sheets", "google.sa"
  description?: string;
  optional?: boolean;
}
/**
 * RequirementError represents a single missing requirement with actionable info
 */
export interface RequirementError {
  type: string; // "secret" | "integration" | "scope"
  key: string; // The requirement key that's missing
  message: string; // Human-readable error message
  action?: SetupAction;
}
/**
 * SetupAction provides actionable info for resolving a missing requirement
 */
export interface SetupAction {
  type: string; // "add_secret" | "connect" | "add_scopes"
  provider?: string; // For integration actions
  scopes?: string[]; // Scopes to request
}

//////////
// source: shadeform.go

export type InstanceCloudProvider = string;
export const CloudAWS: InstanceCloudProvider = "aws";
export const CloudAzure: InstanceCloudProvider = "azure";
export const CloudLambdaLabs: InstanceCloudProvider = "lambdalabs";
export const CloudTensorDock: InstanceCloudProvider = "tensordock";
export const CloudRunPod: InstanceCloudProvider = "runpod";
export const CloudLatitude: InstanceCloudProvider = "latitude";
export const CloudJarvisLabs: InstanceCloudProvider = "jarvislabs";
export const CloudOblivus: InstanceCloudProvider = "oblivus";
export const CloudPaperspace: InstanceCloudProvider = "paperspace";
export const CloudDatacrunch: InstanceCloudProvider = "datacrunch";
export const CloudMassedCompute: InstanceCloudProvider = "massedcompute";
export const CloudVultr: InstanceCloudProvider = "vultr";
export const CloudShade: InstanceCloudProvider = "shade";
export type InstanceStatus = string;
export const InstanceStatusPending: InstanceStatus = "pending";
export const InstanceStatusActive: InstanceStatus = "active";
export const InstanceStatusDeleted: InstanceStatus = "deleted";
export interface Instance {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  cloud: InstanceCloudProvider;
  name: string;
  region: string;
  shade_cloud: boolean;
  shade_instance_type: string;
  cloud_instance_type: string;
  cloud_assigned_id: string;
  os?: string;
  ssh_key_id?: string;
  ssh_user: string;
  ssh_port: number /* int */;
  ip: string;
  status: InstanceStatus;
  cost_estimate: string;
  hourly_price: number /* int */; // in cents
  template_id?: string;
  volume_ids?: string[];
  tags?: string[];
  configuration?: InstanceConfiguration;
  launch_configuration?: InstanceLaunchConfiguration;
  auto_delete?: InstanceThresholdConfig;
  alert?: InstanceThresholdConfig;
  volume_mount?: InstanceVolumeMountConfig;
  envs?: InstanceEnvVar[];
}
export interface InstanceConfiguration {
  gpu_type: string;
  interconnect: string;
  memory_in_gb: number /* int */;
  num_gpus: number /* int */;
  os: string;
  storage_in_gb: number /* int */;
  vcpus: number /* int */;
  vram_per_gpu_in_gb: number /* int */;
}
export interface InstanceLaunchConfiguration {
  type: string;
  docker_configuration?: InstanceDockerConfig;
  script_configuration?: InstanceScriptConfig;
}
export interface InstanceDockerConfig {
  image: string;
  args?: string;
  shared_memory_in_gb?: number /* int */;
  envs?: InstanceEnvVar[];
  port_mappings?: InstancePortMapping[];
  volume_mounts?: InstanceVolumeMount[];
}
export interface InstanceScriptConfig {
  base64_script: string;
}
export interface InstancePortMapping {
  host_port: number /* int */;
  container_port: number /* int */;
}
export interface InstanceVolumeMount {
  host_path: string;
  container_path: string;
}
export interface InstanceThresholdConfig {
  date_threshold?: string;
  spend_threshold?: string;
}
export interface InstanceVolumeMountConfig {
  auto: boolean;
}
export interface InstanceEnvVar {
  name: string;
  value: string;
}

//////////
// source: system_info.go

export interface TelemetrySystemInfo {
  cpus: CPU[];
  ram: RAM;
  gpus: GPU[];
  volumes: Volume[];
}
export interface CPU {
  name: string;
  vendor_id: string;
  family: string;
  model: string;
  cores: number /* int */;
  frequency: string;
  usage: number /* float64 */;
  normalized_usage: number /* float64 */;
}
export interface Volume {
  name: string;
  size: number /* uint64 */;
  used: number /* uint64 */;
  free: number /* uint64 */;
  usage: number /* float64 */;
}
export interface RAM {
  total: number /* uint64 */;
  available: number /* uint64 */;
  used: number /* uint64 */;
  free: number /* uint64 */;
  usage: number /* float64 */;
  total_physical: number /* uint64 */;
  total_usable: number /* uint64 */;
  bootloader_usage: number /* uint64 */;
  swap_total: number /* uint64 */;
  swap_used: number /* uint64 */;
  swap_free: number /* uint64 */;
  swap_usage: number /* float64 */;
}
export interface GPU {
  id: string;
  name: string;
  index: number /* int */;
  cuda_version: string;
  driver_version: string;
  memory_used: number /* uint64 */;
  memory_total: number /* uint64 */;
  temperature: number /* uint32 */;
}

//////////
// source: task.go

export type TaskStatus = number /* int */;
export const TaskStatusUnknown: TaskStatus = 0; // 0
export const TaskStatusReceived: TaskStatus = 1; // 1
export const TaskStatusQueued: TaskStatus = 2; // 2
export const TaskStatusScheduled: TaskStatus = 3; // 3
export const TaskStatusPreparing: TaskStatus = 4; // 4
export const TaskStatusServing: TaskStatus = 5; // 5
export const TaskStatusSettingUp: TaskStatus = 6; // 6
export const TaskStatusRunning: TaskStatus = 7; // 7
export const TaskStatusUploading: TaskStatus = 8; // 8
export const TaskStatusCompleted: TaskStatus = 9; // 9
export const TaskStatusFailed: TaskStatus = 10; // 10
export const TaskStatusCancelled: TaskStatus = 11; // 11
export type Infra = string;
export const InfraPrivate: Infra = "private";
export const InfraCloud: Infra = "cloud";
export const InfraPrivateFirst: Infra = "private_first";
export interface TaskEvent {
  id: string;
  created_at: string /* RFC3339 */;
  event_time: string /* RFC3339 */;
  task_id: string;
  status: TaskStatus;
}
export type TaskLogType = number /* int */;
export const TaskLogTypeBuild: TaskLogType = 0; // 0
export const TaskLogTypeRun: TaskLogType = 1;
export const TaskLogTypeServe: TaskLogType = 2;
export const TaskLogTypeSetup: TaskLogType = 3;
export const TaskLogTypeTask: TaskLogType = 4;
export interface TaskLog {
  id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  task_id: string;
  log_type: TaskLogType;
  content: string;
}
export interface TaskDTO extends BaseModel, PermissionModelDTO {
  graph_id?: string;
  user_public_key: string;
  engine_public_key: string;
  is_featured: boolean;
  status: TaskStatus;
  app_id: string;
  app?: AppDTO;
  app_version_id: string;
  app_version?: AppVersionDTO;
  app_variant: string;
  function: string; // Function called on multi-function apps
  infra: Infra;
  workers: string[];
  flow_id?: string;
  flow_run_id?: string;
  sub_flow_run_id?: string;
  chat_id?: string;
  agent_id?: string;
  agent_version_id?: string;
  agent?: AgentDTO;
  engine_id?: string;
  engine?: EngineStateSummary;
  worker_id?: string;
  worker?: WorkerStateSummary;
  webhook?: string;
  setup?: any;
  input: any;
  output: any;
  error: string;
  rating: ContentRating;
  events: TaskEvent[];
  logs: TaskLog[];
  telemetry: TimescaleTask[];
  usage_events: (UsageEvent | undefined)[];
  transaction_id?: string;
  transaction?: Transaction;
}
export interface TimescaleTask {
  id: string;
  timestamp: string /* RFC3339 */;
  task_id?: string;
  task_seq: number /* int */;
  app_id: string;
  app_version_id: string;
  engine_id: string;
  engine_resources: TelemetrySystemInfo;
  worker_id: string;
  system_info: TelemetrySystemInfo;
}

//////////
// source: team.go

export type TeamType = string;
export const TeamTypePersonal: TeamType = "personal";
export const TeamTypeTeam: TeamType = "team";
export const TeamTypeSystem: TeamType = "system";
export interface Team {
  BaseModel: BaseModel;
  type: TeamType;
  username: string;
  email: string;
  name: string;
  avatar_url: string;
  /**
   * SetupCompleted indicates whether the team has completed initial setup (chosen a username)
   * Personal teams start with SetupCompleted=false and a generated temporary username
   */
  setup_completed: boolean;
}
export interface TeamDTO extends BaseModel {
  type: TeamType;
  name: string;
  username: string;
  avatar_url: string;
  email: string;
  setup_completed: boolean;
}
export type TeamRole = string;
export const TeamRoleOwner: TeamRole = "owner";
export const TeamRoleAdmin: TeamRole = "admin";
export const TeamRoleMember: TeamRole = "member";
/**
 * Team-related types
 */
export interface TeamRelationDTO {
  id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  type: TeamType;
  username: string;
  avatar_url: string;
  setup_completed: boolean;
}

//////////
// source: tools.go

/**
 * ToolInvocationFunction contains the function details for a tool invocation
 */
export interface ToolInvocationFunction {
  name: string;
  arguments: StringEncodedMap;
}
/**
 * ToolInvocationStatus represents the execution status of a tool invocation
 */
export type ToolInvocationStatus = string;
export const ToolInvocationStatusPending: ToolInvocationStatus = "pending";
export const ToolInvocationStatusInProgress: ToolInvocationStatus = "in_progress";
export const ToolInvocationStatusAwaitingInput: ToolInvocationStatus = "awaiting_input"; // Waiting for user input (widgets)
export const ToolInvocationStatusAwaitingApproval: ToolInvocationStatus = "awaiting_approval"; // Waiting for HIL approval
export const ToolInvocationStatusCompleted: ToolInvocationStatus = "completed";
export const ToolInvocationStatusFailed: ToolInvocationStatus = "failed";
export const ToolInvocationStatusCancelled: ToolInvocationStatus = "cancelled";
/**
 * ToolInvocationDTO for API responses
 */
export interface ToolInvocationDTO extends BaseModel, PermissionModelDTO {
  chat_message_id: string;
  tool_invocation_id: string;
  type: ToolType;
  execution_id?: string;
  function: ToolInvocationFunction;
  status: ToolInvocationStatus;
  result?: string;
  /**
   * Unified fields
   */
  data?: any;
  widget?: Widget;
}
export interface Tool {
  type: string;
  function: ToolFunction;
}
export interface ToolFunction {
  name: string;
  description: string;
  parameters?: ToolParameters;
  required?: string[];
}
export interface ToolParameters {
  type: string;
  title: string;
  properties?: ToolParameterProperties;
  required?: string[];
}
export type ToolParameterProperties = { [key: string]: ToolParameterProperty};
export interface ToolParameterProperty {
  type: string;
  title: string;
  description: string;
  properties?: ToolParameterProperties;
  items?: ToolParameterProperty;
  required?: string[];
}

//////////
// source: tx.go

/**
 * TransactionType represents the type of credit transaction
 */
export type TransactionType = string;
export const TransactionTypeCredit: TransactionType = "credit"; // Adding credits
export const TransactionTypeDebit: TransactionType = "debit"; // Removing credits
/**
 * Transaction represents a single credit transaction
 */
export interface Transaction {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel; // Includes UserID
  type: TransactionType;
  amount: number /* int64 */; // Can be negative for debits
  reference: string; // External reference (e.g., payment ID)
  notes: string;
  /**
   * Metadata for the transaction
   */
  metadata: { [key: string]: any};
}
/**
 * PaymentRecordStatus represents the status of a payment
 */
export type PaymentRecordStatus = number /* int */;
export const PaymentRecordStatusPending: PaymentRecordStatus = 0;
export const PaymentRecordStatusComplete: PaymentRecordStatus = 1;
export const PaymentRecordStatusFailed: PaymentRecordStatus = 2;
export const PaymentRecordStatusExpired: PaymentRecordStatus = 3;
/**
 * PaymentRecordType represents the type of payment
 */
export type PaymentRecordType = string;
export const PaymentRecordTypeCheckout: PaymentRecordType = "checkout"; // Stripe Checkout session (manual top-up)
export const PaymentRecordTypeAutoRecharge: PaymentRecordType = "auto_recharge"; // Direct charge (auto-recharge)
/**
 * PaymentRecord stores Stripe payment details for both checkout sessions and direct charges
 */
export interface PaymentRecord {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  type: PaymentRecordType;
  status: PaymentRecordStatus;
  amount: number /* int64 */; // Amount in cents
  stripe_customer_id: string; // Stripe customer ID
  payment_intent_id: string; // Stripe PaymentIntent ID
  receipt_url: string; // Receipt URL
  /**
   * Checkout-specific fields (only set for checkout type)
   */
  session_id: string; // Stripe Checkout Session ID
  session_url: string; // Checkout URL
}

//////////
// source: usage.go

export type UsageEventResourceTier = string;
export const UsageEventResourceTierPrivate: UsageEventResourceTier = "private";
export const UsageEventResourceTierCloud: UsageEventResourceTier = "cloud";
/**
 * MetaItemType is the type discriminator for MetaItem
 */
export type MetaItemType = string;
export const MetaItemTypeText: MetaItemType = "text";
export const MetaItemTypeImage: MetaItemType = "image";
export const MetaItemTypeVideo: MetaItemType = "video";
export const MetaItemTypeAudio: MetaItemType = "audio";
export const MetaItemTypeRaw: MetaItemType = "raw";
/**
 * VideoResolution represents standard video resolution presets
 */
export type VideoResolution = string;
export const VideoRes480P: VideoResolution = "480p";
export const VideoRes720P: VideoResolution = "720p";
export const VideoRes1080P: VideoResolution = "1080p";
export const VideoRes1440P: VideoResolution = "1440p";
export const VideoRes4K: VideoResolution = "4k";
/**
 * MetaItem represents metadata about an input or output item
 */
export interface MetaItem {
  type: MetaItemType;
  /**
   * Text fields
   */
  tokens?: number /* int */;
  /**
   * Image/Video shared fields
   */
  width?: number /* int */;
  height?: number /* int */;
  resolution_mp?: number /* float64 */;
  /**
   * Image specific fields
   */
  steps?: number /* int */;
  count?: number /* int */;
  /**
   * Video specific fields
   */
  resolution?: VideoResolution;
  seconds?: number /* float64 */;
  fps?: number /* int */;
  /**
   * Audio specific fields
   */
  sample_rate?: number /* int */;
  /**
   * App-specific key-value pairs for custom pricing factors
   */
  extra?: { [key: string]: any};
}
/**
 * OutputMeta contains structured metadata about task inputs and outputs for pricing calculation
 */
export interface OutputMeta {
  inputs: MetaItem[];
  outputs: MetaItem[];
}
export interface UsageEvent {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  usage_billing_record_id: string;
  reference_id: string;
  resource_id: string;
  /**
   * Resource tier
   */
  tier: UsageEventResourceTier;
  type: string;
  model: string;
  quantity: number /* int64 */;
  unit: string;
}
export interface UsageBillingRecord {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  /**
   * Fee breakdown (all in microcents)
   */
  total: number /* int64 */;
  /**
   * User debit (total charged)
   */
  user_debit_transaction_id: string;
  user_debit_transaction?: Transaction;
  /**
   * Resource owner credit (for providing compute)
   */
  resource_credit_transaction_id: string;
  resource_credit_transaction?: Transaction;
  /**
   * Creator royalty credit (app creator earnings)
   */
  royalty_credit_transaction_id: string;
  royalty_credit_transaction?: Transaction;
  /**
   * Inference fee credit (platform fee)
   */
  inference_credit_transaction_id: string;
  inference_credit_transaction?: Transaction;
  /**
   * Partner fee credit (cloud API fee)
   */
  partner_credit_transaction_id: string;
  partner_credit_transaction?: Transaction;
}
export interface UsageBillingRefund {
  BaseModel: BaseModel;
  PermissionModel: PermissionModel;
  usage_billing_record_id: string;
  usage_billing_record?: UsageBillingRecord;
  /**
   * User refund (total refunded)
   */
  user_debit_refund_transaction_id: string;
  user_debit_refund_transaction?: Transaction;
  /**
   * Resource owner reversal
   */
  resource_credit_refund_transaction_id: string;
  resource_credit_refund_transaction?: Transaction;
  /**
   * Creator royalty reversal
   */
  royalty_credit_refund_transaction_id: string;
  royalty_credit_refund_transaction?: Transaction;
  /**
   * Inference fee reversal
   */
  inference_credit_refund_transaction_id: string;
  inference_credit_refund_transaction?: Transaction;
  /**
   * Partner fee reversal
   */
  partner_credit_refund_transaction_id: string;
  partner_credit_refund_transaction?: Transaction;
}

//////////
// source: user.go

/**
 * User-related types
 */
export interface User {
  BaseModel: BaseModel; // anonymous embedding
  default_team_id: string;
  role: Role;
  email: string;
  email_verified: boolean;
  name: string;
  full_name: string;
  avatar_url: string;
  metadata: UserMetadata;
}
export type Role = string;
export const RoleGuest: Role = "guest";
export const RoleUser: Role = "user";
export const RoleAdmin: Role = "admin";
export const RoleSystem: Role = "system";
export interface UserDTO extends BaseModel {
  default_team_id: string;
  role: Role;
  email: string;
  name: string;
  full_name: string;
  avatar_url: string;
  metadata: UserMetadata;
}
/**
 * User-related types
 */
export interface UserRelationDTO {
  id: string;
  created_at: string /* RFC3339 */;
  updated_at: string /* RFC3339 */;
  role: Role;
  avatar_url: string;
}
export interface UserMetadata {
  user_id: string;
  completed_onboarding: boolean;
  use_case: string;
  use_case_reason: string;
  use_case_privacy: string;
}

//////////
// source: widget.go

/**
 * WidgetAction represents an action triggered by a widget button
 */
export interface WidgetAction {
  type: string;
  payload?: { [key: string]: any};
}
/**
 * WidgetActionButton represents a button in a widget's action bar
 */
export interface WidgetActionButton {
  label: string;
  action: WidgetAction;
  variant?: string; // "default" | "secondary" | "outline" | "ghost" | "destructive"
}
/**
 * WidgetNodeType constants
 * Primitives (literal values): text, markdown, image, badge, button, input, select, checkbox, row, col
 * Data-bound (read from ToolInvocation.Data): plan-list, key-value, status-badge
 */
export type WidgetNodeType = string;
/**
 * Primitive node types (render literal values)
 */
export const WidgetNodeTypeText: WidgetNodeType = "text";
export const WidgetNodeTypeMarkdown: WidgetNodeType = "markdown";
export const WidgetNodeTypeImage: WidgetNodeType = "image";
export const WidgetNodeTypeBadge: WidgetNodeType = "badge";
export const WidgetNodeTypeButton: WidgetNodeType = "button";
export const WidgetNodeTypeInput: WidgetNodeType = "input";
export const WidgetNodeTypeSelect: WidgetNodeType = "select";
export const WidgetNodeTypeCheckbox: WidgetNodeType = "checkbox";
export const WidgetNodeTypeRow: WidgetNodeType = "row";
export const WidgetNodeTypeCol: WidgetNodeType = "col";
/**
 * Data-bound node types (read from ToolInvocation.Data via DataKey)
 */
export const WidgetNodeTypePlanList: WidgetNodeType = "plan-list"; // Renders plan steps from Data
export const WidgetNodeTypeKeyValue: WidgetNodeType = "key-value"; // Renders key-value pairs from Data
export const WidgetNodeTypeStatusBadge: WidgetNodeType = "status-badge"; // Renders status badge from Data
/**
 * WidgetNode represents a UI element in a widget (text, input, select, etc.)
 */
export interface WidgetNode {
  type: WidgetNodeType;
  value?: string;
  src?: string;
  alt?: string;
  label?: string;
  name?: string;
  placeholder?: string;
  defaultValue?: string;
  variant?: string;
  action?: WidgetAction;
  options?: WidgetSelectOption[];
  defaultChecked?: boolean;
  children?: WidgetNode[];
  gap?: number /* int */;
  /**
   * Data binding - for data-bound node types, specifies which key in ToolInvocation.Data to read
   * Empty string means read entire Data object (useful for key-value display)
   */
  dataKey?: string;
}
/**
 * WidgetSelectOption represents an option in a select widget
 */
export interface WidgetSelectOption {
  label: string;
  value: string;
}
/**
 * Widget represents an interactive widget for display in chat
 * Type is either "ui" (structured nodes) or "html" (raw HTML)
 * For "ui" widgets, data-bound nodes read values from ToolInvocation.Data
 */
export interface Widget {
  type: string; // "ui" | "html"
  interactive?: boolean;
  title?: string;
  html?: string; // For type="html"
  json?: string; // Original JSON for reference
  children?: WidgetNode[];
  actions?: WidgetActionButton[];
}
